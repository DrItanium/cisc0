;-----------------------------------------------------------------------------
; An implementation of the language specified by Charles H. Moore's book on
; a Problem orientied langauge.
;-----------------------------------------------------------------------------
; Fixed registers
;   - InstructionPoiner : r255 (aka ip)
;	- LinkRegister: r254 (aka lr)
; 	- StackPointer: r253 (aka sp)
; 	- Parameter Stack Top: r252 (aka ptop)
;	- Parameter Stack End: r251 (aka pend)
;	- Return Stack Top: r250 (aka rtop)
;	- Return Stack End: r249 (aka rend)
;	These are used internally for passing arguments around to leaf functions
;	- Safe Param 0: r248 (spar0)
;	- Safe Param 1: r247 (spar1)
;	- Safe Param 2: r246 (spar2)
;	- Safe Param 3: r245 (spar3)
;	- Safe Result 0: r244 (sres0)
;	- Safe Result 1: r243 (sres1)
;	- Safe Result 2: r242 (sres2)
;	- Safe Result 3: r241 (sres3)
;	- Safe Temporary 0: r240 (stmp0)
;	- Safe Temporary 1: r239 (stmp1)
;	- Safe Temporary 2: r238 (stmp2)
;	- Safe Temporary 3: r237 (stmp3)
;	- ASCII Space: r236 (space)
; 	- Safe Temporary 4: r235 (stmp4)
;	- Safe Temporary 5: r234 (stmp5)
;	- Safe Temporary 6: r233 (stmp6)
;	- Max Word Length: r232 (wlen)
;	- Safe Temporary 7: r231 (stmp7)
;	- Zero register: r230 (zero)
;	- FETCH / DEPOSIT current: r229 (fdcur)
;	- input pointer: r228 (inptr)
;	- output pointer: r227 (outptr)
;-----------------------------------------------------------------------------
; Parameter passing conventions
;  If the given subroutine calls another subroutine then you need to save
;  the current lr onto the return stack, otherwise you can just use it.
;  lr will always be populated in the case of subroutine calls
;-----------------------------------------------------------------------------
; setup the parameter and return stack pointers inside stack memory
;-----------------------------------------------------------------------------
; First setup the memory addresses using the org directive so that it is easy
; to keep track of
;-----------------------------------------------------------------------------
@data
@org 0xFFFF
	@label ParameterStackBottom ; this will make sure that 0x0000 is never wasted
@org 0x7FFF
	@label ReturnStackBottom
@org 0x0000
@code
@org 0x0000
; setup the initial values of the registers
set ptop ParameterStackBottom
set pend ParameterStackBottom
set rtop ReturnStackBottom
set rend ReturnStackBottom				 
set space 0x20							; fixed register for the ascii space code
set wlen 62								; the maximum number of characters allowed in a single word (- 1 for the terminator)
@label DONE								; top of our "control loop", what he calls RETURN
	set spar0 WORD_BUFFER				; load the front of the word buffer
	goto.link lr WORD					; read the next word
	goto.link lr print					; print it out
	set spar0 msg_newline				; 
	goto.link lr print					; print out a newline
	goto DONE							; 
;-----------------------------------------------------------------------------
; Prints a string character by character until we see a \0
; Inputs:
;	spar0 - what to print out
;-----------------------------------------------------------------------------
@label print
	@label print_loop
		load stmp0 spar0			; load the current char from memory into a register
		goto.if0 stmp0 print_done	; before printing, check to see that we should print, if it is zero then stop
		system 2 stmp0 stmp0		; print the character to the user
		addi spar0 spar0 1			; advance the index pointer to the next character
		goto print_loop				; we're not done yet
	@label print_done
		jump lr						; return using the link register
;-----------------------------------------------------------------------------
; Treat the top of the stack as an address and loads its contents in place of
; the original address
;-----------------------------------------------------------------------------
@label AtVerb
	swap sp ptop 					; set the parameter stack as the current target
	pop stmp0						; get the top element
	load stmp1 stmp0				; load, from memory, the data at the top of the stack
	push stmp1						; push the loaded value onto the stack
	swap sp ptop					; restore the previous value to the stack pointer and update ptop
	jump lr							; we're done here, go back
;-----------------------------------------------------------------------------
; Store second in memory at the address stored in top
;-----------------------------------------------------------------------------
@label EqualsVerb
	swap sp ptop					; load the top of the parameter stack
	pop stmp0						; get the top element (drop the element)
	pop stmp1 						; get the second element (drop the element)
	store stmp0 stmp1				; data[stmp0] = stmp1
	swap sp ptop					; restore the previous value and update ptop
									; TODO: put error checking here of the parameter stack
	jump lr							; we're done here!
;-----------------------------------------------------------------------------
; Takes in the offending word, an error message, prints them, then clears the
; stacks and then calls DONE.
; Inputs are on r32, r33 for this routine
;	spar0 - word that did a bad thing
;   spar1 - error type
;-----------------------------------------------------------------------------
@label ERROR								; Error routine
	move ptop pend 							; overwrite the current parameter stack location with the bottom
	move rtop rend							; overwrite the current return stack location with the bottom
	goto.link lr	print					; print the offending word that did the bad thing
	move spar0 spar1 						; now we need to print the error type so setup the arguments
	goto.link lr print						; and print it
	goto DONE								; and we're done!
;-----------------------------------------------------------------------------
; SHUTDOWN / DIE - End the program and shutdown the machine
;-----------------------------------------------------------------------------
@label SHUTDOWN
@label DIE
	system 0, spar0, spar0


;-----------------------------------------------------------------------------
; WORD: Read the next word in the input
;	spar0 - pointer to temporary storage to save the current word
;-----------------------------------------------------------------------------
@label WORD
	move stmp2 spar0												; copy the pointer address to temporary storage so we can mess with it
	set	stmp3 WORD_read_data										; where to jump to if we see a space
	set	stmp4 WORD_reassign_jumps 									; where to jump to when wanting to handle storage
	set stmp5 0														; The number of characters in the word
	@label WORD_read_data											; Find all leading spaces and discard them
		system 1 stmp0 stmp0										; load the next character from input
		eq stmp1 stmp0 space 										; check and see if it is a space
		if1 stmp1 stmp3 stmp4										; if we see a space then jump
																	; to stmp2 otherwise it is to
																	; stmp4. Initially this is
																	; setup to skip all prefixed
																	; spaces. Once a non-space has
																	; been seen then the jumps
																	; are reassigned to process (and store) 
																	; the word until we see another space
																	;
		@label WORD_reassign_jumps									; This should only be executed once!
			set stmp3 WORD_done_reading								; terminate if we see another space at this point
			set stmp4 WORD_store_word								; continue processing but skip this code
																	;
		@label WORD_store_word										; The actual save operation
			store stmp2 stmp0										; store the character into the character buffer
			addi stmp2 stmp2 1										; move to the next character
			gt stmp1 stmp5 wlen										; did we go over the maximum word length?
			goto.if1 stmp1 WORD_too_large_word_ERROR				; If so then error out
			addi stmp5 stmp5 1										; increment the word length count 
			goto WORD_read_data										; restart the process
																	;
	@label WORD_too_large_word_ERROR								; we need to setup the pointers for error states
		store stmp2 zero											; rewrite zero to the end of word entry
		set spar1 errmsg_WORD_too_large_word						; load the error message 
		goto ERROR													; get out of here!
	@label WORD_done_reading										; WOOOO we're done
		store stmp2 zero											; put a zero in the current cell, or the last one
		jump lr														; return
;-----------------------------------------------------------------------------
; SUBROUTINE
; Load the character defined by the input pointer into the fdcur register, 
; then advance inptr by one
;-----------------------------------------------------------------------------
@label FETCH
	load fdcur inptr
	addi inptr inptr 1
	jump lr

;-----------------------------------------------------------------------------
; SUBROUTINE
; Store the character in fdcur in the address described by outptr, then 
; advance outptr by one
;-----------------------------------------------------------------------------
@label DEPOSIT
	store outptr fdcur
	addi outptr outptr 1
	jump lr

;-----------------------------------------------------------------------------
; SUBROUTINE
; Parse a number, has two entry points as described in the book. SIGNED and
; NATURAL. SIGNED starts with a -, natural does not
;-----------------------------------------------------------------------------
@label NUMBER
	swap sp rtop
	push lr
	goto.link lr SIGNED
	pop lr
	swap sp rtop
	jump lr
@label SIGNED				
@label NATURAL
	jump lr

@data
@label msg_newline
	; \n
	@declare 0x0A
	@declare 0x00
@data
@label errmsg_WORD_too_large_word
	; " WORD TOO LARGE!"
	@declare 0x20
	@declare 0x57
	@declare 0x4f
	@declare 0x52
	@declare 0x44
	@declare 0x20
	@declare 0x54
	@declare 0x4f
	@declare 0x4f
	@declare 0x20
	@declare 0x4c
	@declare 0x41
	@declare 0x52
	@declare 0x47
	@declare 0x45
	@declare 0x21
	@declare 0xa
	@declare 0x00
@label WORD_BUFFER
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
