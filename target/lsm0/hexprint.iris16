; Routine for printing the contents of a register!
#define sp r255
#define v0 r0
#define v1 r1
#define v2 r2
#define v3 r3
#define return0 r64
#define return1 r65
#define return2 r66
#define arg0 r32
#define arg1 r33
#define arg2 r34
#define arg3 r35
#define temp0 r96
#define temp1 r97
#define temp2 r98
#define temp3 r99
#define vp0 p15
#define vp1 p14

#define savelr(stack) \
        mflr v0 \
        push stack v0
#define restorelr(stack) \
        pop v0 stack \
        mtlr v0
#define fnret blr

#define bteqia(src0, immediate, destination) \
        set v0 immediate \
        eq vp0 src0 v0 \
        bt vp0 destination 
#define bteqir(src0, immediate, destination) \
        set v0 immediate \
        eq vp0 src0 v0 \
        bt vp0 destination
        
#define clear(reg) set reg 0x0000
#define increment(reg) addi reg reg 0x1
#define decrement(reg) subi reg reg 0x1
#define double(reg) muli reg reg 0x2
#define halve(reg) divi reg reg 0x2


#define wideImmediateInstruction(op, dest, src0, immediate) \
    set v0 immediate \
    op dest src0 v0 
#define addiw(dest, src0, immediate) wideImmediateInstruction(add, dest, src0, immediate)
#define andiw(dest, src0, immediate) wideImmediateInstruction(and, dest, src0, immediate)



@code

@label PRINT_CODE_AS_HEX
    savelr(sp)
	push sp arg0				; save arg0 to the stack since it is the lower half
	move arg0 arg1				; arg1 is now arg0 since it is the upper half, needs to be printed first
	jl PRINT_REGISTER_AS_HEX ; Perform the print
	pop arg0 sp				; restore arg0
	jl PRINT_REGISTER_AS_HEX ; printout the lower half
    restorelr(sp)
    fnret

@label TRANSLATE_LOWER4_TO_HEX
	; translate the lower 4 bits of the register
    andiw(arg0, arg0, 0x000F)
    addiw(arg0, arg0, HEX_PRINT_TRANSLATION_TABLE)
	ld return0 arg0
	fnret

@label PRINT_REGISTER_AS_HEX 
    savelr(sp)
	push sp temp0
	push sp temp1
	push sp temp2
	push sp temp3
	shri temp0 arg0 12
	shri temp1 arg0 8
	shri temp2 arg0 4
	move temp3 arg0
	; now do the other stuffs
	move arg0 temp0
	jl PRINT_HEX_CHARACTER_FROM_LOWER4
	move arg0 temp1
	jl PRINT_HEX_CHARACTER_FROM_LOWER4
	move arg0 temp2
	jl PRINT_HEX_CHARACTER_FROM_LOWER4
	move arg0 temp3
	jl PRINT_HEX_CHARACTER_FROM_LOWER4
	pop temp3 sp
	pop temp2 sp
	pop temp1 sp
	pop temp0 sp
    restorelr(sp)
	fnret

@label PRINT_HEX_CHARACTER_FROM_LOWER4
    savelr(sp)
	jl TRANSLATE_LOWER4_TO_HEX
    restorelr(sp)
	move arg0 return0
	b PRINT_CHARACTER
@label PRINT_NEWLINE
	set arg0 0xa
	b PRINT_CHARACTER
@label PRINT_CHARACTER
	set arg1 0x0002
	b IO_WRITE
@label TERMINATE_EXECUTION
	set arg1 0x0000
	b IO_WRITE
@label READ_CHARACTER
	set arg0 0x0003
	b IO_READ
@label HEX_CHAR_TO_NUMBER
	; convert a given value to binary hex
    andiw(arg0, arg0, 0x00FF) ; make sure we're not overflowed
    addiw(arg0, arg0, HEX_PRINT_TRANSLATION_TABLE)
	ld return0 arg0			; Load the corresponding offset from memory
	fnret

@label IO_READ
	ldio return0 arg0
	fnret
@label IO_WRITE
	stio arg1 arg0
	fnret
@label OP_ADD
	add return0 arg0 arg1
	fnret
@label OP_SUB
	sub return0 arg0 arg1
	fnret
@label OP_MUL
	mul return0 arg0 arg1
	fnret
@label OP_DIV
	div return0 arg0 arg1
	fnret
@label OP_REM
	rem return0 arg0 arg1
	fnret
@label OP_SHIFT_LEFT
	shl return0 arg0 arg1
	fnret
@label OP_SHIFT_RIGHT
	shr return0 arg0 arg1
	fnret
@label OP_BINARY_AND
	and return0 arg0 arg1
	fnret
@label OP_BINARY_OR
	or return0 arg0 arg1
	fnret
@label OP_UNARY_NOT
	not return0 arg0
	fnret
@label OP_BINARY_XOR
	xor return0 arg0 arg1
	fnret
@label CALL
	jr r31
@label RETURN 
	fnret

@label OP_NAND
	and return0 arg0 arg1
	not return0 return0
	fnret

@label OP_NOR
	or return0 arg0 arg1
	not return0 return0
	fnret
@label OP_LOAD
	; arg0 - address
	; arg1 - memory space
	; return0 - error?
	; return1 - ret0
	; return2 - ret1
    clear(return0)
    clear(return1)
    clear(return2)
    bteqia(arg1, 0, OP_DATA_LOAD)
    bteqia(arg1, 1, OP_CODE_LOAD)
    bteqia(arg1, 2, OP_IO_LOAD)
	set return0 0x1
	b OP_LOAD_FAILURE
	@label OP_DATA_LOAD
		ld return1 arg0
		b OP_LOAD_SUCCESSFUL
	@label OP_CODE_LOAD
		ldc arg0 return1 return2
		b OP_LOAD_SUCCESSFUL
	@label OP_IO_LOAD
		ldio return1 arg0
		b OP_SUCCESSFUL
	@label OP_LOAD_FAILURE
	@label OP_LOAD_SUCCESSFUL
	@label OP_LOAD_DONE
		fnret

@label OP_STORE
	; arg0 - memory space
	; arg1 - address
	; r34 - lower half / value
	; r35 - upper half (used only in code writes)
	; return0 - error?
	set return0 0x0
    bteqia(arg0, 0, OP_DATA_STORE) ; data
    bteqia(arg0, 1, OP_CODE_STORE)
    bteqia(arg0, 2, OP_IO_STORE)
	set return0 0x1
	b OP_STORE_FAILURE
	@label OP_DATA_STORE
		st arg1 r34
		b OP_STORE_SUCCESSFUL
	@label OP_CODE_STORE
		stc arg1 r34 r35
		b OP_STORE_SUCCESSFUL
	@label OP_IO_STORE
		stio arg1 r34
		b OP_SUCCESSFUL
	@label OP_STORE_FAILURE
	@label OP_STORE_SUCCESSFUL
	@label OP_STORE_DONE
		fnret
	
	
@label OP_IF_TRUE
	; arg0 - condition
	; arg1 - on true
	; r34 - on false
	ift arg0 arg1 r34
@label OP_IF_FALSE
	; arg0 - condition
	; arg1 - on true
	; r34 - on false
	iff arg0 arg1 r34

@data
; in the last page, first section, we have the ascii table
@org 0xF100
	@label HEX_PRINT_TRANSLATION_TABLE
	@declare 0x30
	@declare 0x31
	@declare 0x32
	@declare 0x33
	@declare 0x34
	@declare 0x35
	@declare 0x36
	@declare 0x37
	@declare 0x38
	@declare 0x39
	@declare 0x41
	@declare 0x42
	@declare 0x43
	@declare 0x44
	@declare 0x45
	@declare 0x46
	; 0xF110
@org 0xF130
	@declare 0x0
	@declare 0x1
	@declare 0x2
	@declare 0x3
	@declare 0x4
	@declare 0x5
	@declare 0x6
	@declare 0x7
	@declare 0x8
	@declare 0x9
@org 0xF141
	@declare 0xA
	@declare 0xB
	@declare 0xC
	@declare 0xD
	@declare 0xE
	@declare 0xF
