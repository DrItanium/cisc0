; Routine for printing the contents of a register!

@code

@label PRINT_CODE_AS_HEX
	push sp lr
	push sp r32				; save r32 to the stack since it is the lower half
	move r32 r33				; r33 is now r32 since it is the upper half, needs to be printed first
	jl PRINT_REGISTER_AS_HEX ; Perform the print
	pop r32 sp				; restore r32
	jl PRINT_REGISTER_AS_HEX ; printout the lower half
	pop lr sp
	jr lr

@label TRANSLATE_LOWER4_TO_HEX
	; translate the lower 4 bits of the register
	push sp r96
	set r96 0x000F
	and r32 r32 r96
	set r96 HEX_PRINT_TRANSLATION_TABLE
	add r32 r32 r96
	ld r64 r32
	pop r96 sp
	jr lr

@label PRINT_REGISTER_AS_HEX 
	push sp lr
	push sp r96
	push sp r97
	push sp r98
	push sp r99
	shri r96 r32 12
	shri r97 r32 8
	shri r98 r32 4
	move r99 r32
	; now do the other stuffs
	move r32 r96
	jl PRINT_HEX_CHARACTER_FROM_LOWER4
	move r32 r97
	jl PRINT_HEX_CHARACTER_FROM_LOWER4
	move r32 r98
	jl PRINT_HEX_CHARACTER_FROM_LOWER4
	move r32 r99
	jl PRINT_HEX_CHARACTER_FROM_LOWER4
	pop r99 sp
	pop r98 sp
	pop r97 sp
	pop r96 sp
	pop lr sp
	jr lr

@label PRINT_HEX_CHARACTER_FROM_LOWER4
	push sp lr
	jl TRANSLATE_LOWER4_TO_HEX
	pop lr sp
	move r32 r64
	j PRINT_CHARACTER
@label PRINT_NEWLINE
	set r32 0xa
	j PRINT_CHARACTER
@label PRINT_CHARACTER
	set r33 0x0002
	j IO_WRITE
@label TERMINATE_EXECUTION
	set r33 0x0000
	j IO_WRITE
@label READ_CHARACTER
	set r32 0x0003
	j IO_READ
@label HEX_CHAR_TO_NUMBER
	; convert a given value to binary hex
	push sp r96
	set r96 0x00FF
	and r32 r32 r97		; make sure we're not overflowed
	set r96 HEX_PRINT_TRANSLATION_TABLE
	add r32 r32 r96		; add the base translation table offset
	ld r64 r32			; Load the corresponding offset from memory
	pop r96 sp
	jr lr

@label IO_READ
	ldio r64 r32
	jr lr
@label IO_WRITE
	stio r33 r32
	jr lr
@label OP_ADD
	add r64 r32 r33
	jr lr
@label OP_SUB
	sub r64 r32 r33
	jr lr
@label OP_MUL
	mul r64 r32 r33
	jr lr
@label OP_DIV
	div r64 r32 r33
	jr lr
@label OP_REM
	rem r64 r32 r33
	jr lr
@label OP_SHIFT_LEFT
	shl r64 r32 r33
	jr lr
@label OP_SHIFT_RIGHT
	shr r64 r32 r33
	jr lr
@label OP_BINARY_AND
	and r64 r32 r33
	jr lr
@label OP_BINARY_OR
	or r64 r32 r33
	jr lr
@label OP_UNARY_NOT
	not r64 r32
	jr lr
@label OP_BINARY_XOR
	xor r64 r32 r33
	jr lr
@label CALL
	jr r31
@label RETURN 
	jr lr

@label OP_NAND
	and r64 r32 r33
	not r64 r64
	jr lr

@label OP_NOR
	or r64 r32 r33
	not r64 r64
	jr lr

@label OP_LOAD
	; r32 - address
	; r33 - memory space
	; r64 - error?
	; r65 - ret0
	; r66 - ret1
	push sp r96
	set r64 0x0
	set r65 0x0
	set r66 0x0
	eqi r96 r33 0 ; data
	jt r96 OP_DATA_LOAD
	eqi r96 r33 1
	jt r96 OP_CODE_LOAD
	eqi r96 r33 2
	jt r96 OP_IO_LOAD
	set r64 0x1
	j OP_LOAD_FAILURE
	@label OP_DATA_LOAD
		ld r65 r32
		j OP_LOAD_SUCCESSFUL
	@label OP_CODE_LOAD
		ldc r32 r65 r66
		j OP_LOAD_SUCCESSFUL
	@label OP_IO_LOAD
		ldio r65 r32
		j OP_SUCCESSFUL
	@label OP_LOAD_FAILURE
	@label OP_LOAD_SUCCESSFUL
	@label OP_LOAD_DONE
		pop r96 sp
		jr lr

@label OP_STORE
	; r32 - memory space
	; r33 - address
	; r34 - lower half / value
	; r35 - upper half (used only in code writes)
	; r64 - error?
	push sp r96
	set r64 0x0
	eqi r96 r32 0 ; data
	jt r96 OP_DATA_STORE
	eqi r96 r32 1
	jt r96 OP_CODE_STORE
	eqi r96 r32 2
	jt r96 OP_IO_STORE
	set r64 0x1
	j OP_STORE_FAILURE
	@label OP_DATA_STORE
		st r33 r34
		j OP_STORE_SUCCESSFUL
	@label OP_CODE_STORE
		stc r33 r34 r35
		j OP_STORE_SUCCESSFUL
	@label OP_IO_STORE
		stio r33 r34
		j OP_SUCCESSFUL
	@label OP_STORE_FAILURE
	@label OP_STORE_SUCCESSFUL
	@label OP_STORE_DONE
		pop r96 sp
		jr lr
	
	
@label OP_IF_TRUE
	; r32 - condition
	; r33 - on true
	; r34 - on false
	ift r32 r33 r34
@label OP_IF_FALSE
	; r32 - condition
	; r33 - on true
	; r34 - on false
	iff r32 r33 r34

@label OP_BRANCH_EQ
	; r32 - v0
	; r33 - v1
	

@data
; in the last page, first section, we have the ascii table
@org 0xF100
	@label HEX_PRINT_TRANSLATION_TABLE
	@declare 0x30
	@declare 0x31
	@declare 0x32
	@declare 0x33
	@declare 0x34
	@declare 0x35
	@declare 0x36
	@declare 0x37
	@declare 0x38
	@declare 0x39
	@declare 0x41
	@declare 0x42
	@declare 0x43
	@declare 0x44
	@declare 0x45
	@declare 0x46
	; 0xF110
@org 0xF130
	@declare 0x0
	@declare 0x1
	@declare 0x2
	@declare 0x3
	@declare 0x4
	@declare 0x5
	@declare 0x6
	@declare 0x7
	@declare 0x8
	@declare 0x9
@org 0xF141
	@declare 0xA
	@declare 0xB
	@declare 0xC
	@declare 0xD
	@declare 0xE
	@declare 0xF
