; Since I've never ever done something like this before, I used the picolisp
; reference as a base in defining the cell layout. Unlike picoLisp, this
; machine is really simple but is a good place to start for the time being.
; There is no floating point support nor symbols at this time.
; The machine is defined as having a 24-bit flat memory space internally but
; only 8 megawords are used as user memory with the other half as system and
; internal book keeping. We will call these halves 'zones'. A memory address
; denotes which zone it refers to by looking at bit 23 of an address. 
; zone 0 is system and zone 1 is memory
; An address refering to zone 1 refers to a 21 bit "cell" address because
; each cell is comprised of 4 words or 64-bits in size. Thus the lowest two
; bits are used for basic tagging information. If bit zero is set to one then
; it has been marked for garbage collection. If bit 1 is set to 1 then the car
; is a 30-bit integer. If bit 1 is not set then the cell refers to a list and
; then upper most 8 bits of the half cell refers to extra tagging information. 
; 
; Since pico lisp is so simple with respect to garbage collection, it makes it
; a perfect target for this machine. Thus we have to setup the 21 bit "free list"
; with the first step being to generate routines we need to manipulate lists
; There are also two stacks, a call stack and another being a value stack
;
; 
; addr - free list
; value, r8, r7 - args0-2 respectively
; r0, r1, r2, r3 - temporaries 
; r4, r5 - return value / temporaries
; r9, r10 - temporary, no need to ever save!
; Divide memory into 2 separate "zones",
; 0 - System, Free List, Stacks
; 1 - User Memory
; The zone bit is defined as bit 23 in a memory address
@org 0x00000000
	set 0m1111 sp stackBottom ; setup the stack pointer
	set 0m1111 r8 freeListBegin ; set the bottom of the free list
	set 0m1111 addr NIL ; initialize the free list by pointing to NIL
; setup the machine by first constructing the free list
@label memorySetupLoop
	compare == none addr r8					; see if we are done setting up the free list
	branch cond immediate memoryHasBeenSetup
	copy r0 addr 				; r0 is the address in zone 1
	copy r1 addr 				; r1 is the address in zone 0
	arithmetic add immediate r0 0x4	; next address cell
	arithmetic sub immediate r1 0x4 ; next "free cell" location
	memory store 0m1111 0x0 r1 r0	; store the next address cell in zone1 to car
	memory store 0m1111 0x2 r1 addr ; store the old available address as cdr
	copy addr r1
	branch immediate memorySetupLoop
@label memoryHasBeenSetup
	branch immediate terminate ; just quit for now
@label ReadChar
@label getchar 
	set 0m0001 addr 1
	branch immediate syscall
@label PrintChar
	copy r4 value
@label putchar
	set 0m0001 addr 2
	branch immediate syscall
@label terminate
	zero addr
@label syscall
	system r4
	return

@label clearcell
	; value is the address to the front of the cell
	zero r8
	zero r7
	branch immediate storecell
@label loadcell
	memory load 0m1111 0x0 value r4
	memory load 0m1111 0x2 value r5
	return
@label storecell
	memory store 0m1111 0x0 value r8
	memory store 0m1111 0x2 value r7
	return
	
@label markgcbit
	; mark the lowest most bit of a given dword
	logical or immediate 0m0001 value 0x1
	return

@label Print_OutOfMemory
	branch immediate terminate
@label OutOfMemory
	set 0m1111 r4 NIL
	compare == none addr r4
	return
@label GetMemoryCell
	; need to get a cell from the available list
	branch call immediate OutOfMemory
	branch cond immediate PerformGC
	branch immediate GetMemoryCell_DONE
@label PerformGC
	;branch call immediate GC
	branch call immediate OutOfMemory
	branch cond immediate Print_OutOfMemory
@label GetMemoryCell_DONE
	; grab the cell's address
	memory load 0m1111 0x0 addr r9		; load the car into r9 for returning
	memory load 0m1111 0x2 addr addr    ; pop this element off the list
	return

@label ComputeAddress
	; extract address and extra bits into separate registers r4 and r5
	move 0m0111 r2 value		; raw 24 bit address
	logical and immediate 0m0111 r2 0x007FFFFC
	move 0m1100 r3 value		; extra bits, upper 8 and lower 2
	logical and immediate 0m1001 r3 0xFF000003
    return
@label NextAddress
	; move ahead 4 words
	arithmetic add immediate value 0x4
	return
@label PreviousAddress
	; move back 4 words
	arithmetic sub immediate value 0x4
	return
@label ShouldGarbageCollect
	; inspect the target address to see if the corresponding pair should be garbage collected
	; value - the address to check
	move 0m0001 r4 value
	logical and immediate 0m0001 r4 0x1
	compare > none immediate r4 0x0
	return
@label integerp
	move 0m0001 r4 value
	logical and immediate 0m0001 r4 0x2
	compare > none immediate r4 0x0
	return

@label car
	memory load 0m1111 0x0 value r4
	return
@label cdr
	memory load 0m1111 0x2 value r4
	return
;@label allocateMemoryCell
;	branch call immediate outOfMemory
;	branch cond immediate isOutOfMemory
;	; not out of memory
;	memory load 0m1111 0x0 addr value ; load the car into value
;	memory load 0m1111 0x2 addr addr   ; load the cdr into addr
;	branch immediate loadMemoryCell_Done
;@label isOutOfMemory
;	branch call immediate garbageCollect
;@label loadMemoryCell_Done
;	return
;@label garbageCollect
;	; TODO: implement
;	return
	
@label nilp
	set 0m1111 r4 0x007FFFFC
	compare == none value r4
	return
@org 0x006FFFF0
@label stackBottom
@org 0x006FFFFC
@label freeListBegin
@org 0x007FFFFC
@label freeListEnd
@label NIL
	@dword 0xFF7FFFFC
	@dword NIL
