; Since I've never ever done something like this before, I used the picolisp
; reference as a base in defining the cell layout. Unlike picoLisp, this
; machine is really simple but is a good place to start for the time being.
; There is no floating point support nor symbols at this time.
; The machine is defined as having a 24-bit flat memory space internally but
; only 8 megawords are used as user memory with the other half as system and
; internal book keeping. We will call these halves 'zones'. A memory address
; denotes which zone it refers to by looking at bit 23 of an address. 
; zone 0 is system and zone 1 is memory
; An address refering to zone 1 refers to a 21 bit "cell" address because
; each cell is comprised of 4 words or 64-bits in size. Thus the lowest two
; bits are used for basic tagging information. If bit zero is set to one then
; it has been marked for garbage collection. If bit 1 is set to 1 then the car
; is a 30-bit integer. If bit 1 is not set then the cell refers to a list and
; then upper most 8 bits of the half cell refers to extra tagging information. 
; 
; Since pico lisp is so simple with respect to garbage collection, it makes it
; a perfect target for this machine. Thus we have to setup the 21 bit "free list"
; with the first step being to generate routines we need to manipulate lists
; There are also two stacks, a call stack and another being a value stack
;
; 
; addr - free list
; value, r8, r7 - args0-2 respectively
; r0, r1, r2, r3 - temporaries 
; value, r4, r5 - return value / temporaries
; r9 - unused 
; r10 - parameter stack
; Divide memory into 2 separate "zones",
; 0 - System, Free List, Stacks
; 1 - User Memory
; The zone bit is defined as bit 23 in a memory address
@org 0x00000000
	set 0m1111 sp stackBottom ; setup the stack pointer
	set 0m1111 r0 0x00800000  ; set the start of memory
	set 0m1111 r1 0x00FFFFFC  ; set the end of memory
	set 0m1111 addr NIL ; initialize the free list by pointing to NIL, we're going to be using this like a stack
	;set 0m1111 r10 paramBottom
; setup the machine by first constructing the free list
@label memorySetupLoop
	compare > none r0 r1					; have we gone past the last cell?
	branch cond immediate memoryHasBeenSetup
	memory push 0m1111 r0 addr
	arithmetic add immediate r0 0x4	; next address cell
	branch immediate memorySetupLoop
@label memoryHasBeenSetup
	branch immediate terminate ; just quit for now
@label ReadChar
@label getchar 
	set 0m0001 addr 1
	branch immediate syscall
@label PrintChar
@label putchar
	set 0m0001 addr 2
	branch immediate syscall
@label terminate
	zero addr
@label syscall
	system value 
	return

@label reclaimMemory 
	; go through zone 1 memory and return any cells not marked
	; start at 0x00800000 and go to 0x00FFFFFF
	memory push 0m1111 value
	memory push 0m1111 r0
	set 0m1111 r0 MemoryStart					; Setup the start address, this is the pointer to keep moving
	memory push 0m1111 r1
	set 0m1111 r1 MemoryEnd						; Setup the end address
@label reclaimMemory_Loop
	compare > none r0 r1								; did we go past memory end?
	branch cond immediate reclaimMemory_Done			; if we did then we're done
	; load the current cell's car and check to see if we're marked as keep
	memory load 0m1111 0x0 r0 value						; 
	copy r3 value										; preserve value right now
	branch call immediate isgcbitset					; see if we have the mark bitset
	branch cond immediate reclaimMemory_unmarkgc        ; nope, we can't reclaim this cell
	; now we have to reclaim this current cell
	copy value r0										; need to zero out memory at the given address
	branch call immediate clearcell						;
	; put this given address into the free list
	; save an add by using addr as a stack pointer
	memory push 0m1111 value addr						; push this heap address onto the free list
	branch immediate reclaimMemory_Loop_Advance_Address
@label reclaimMemory_unmarkgc
	; make sure that we unmark the given value
	copy value r3
	branch call immediate unmarkgcbit
	memory store 0m1111 0x0 r0 value
@label reclaimMemory_Loop_Advance_Address
	arithmetic add immediate r0 0x4				; goto the next cell
	branch immediate reclaimMemory_Loop
@label reclaimMemory_Done
	copy addr r2
	memory pop 0m1111 r1
	memory pop 0m1111 r0
	memory pop 0m1111 value
	return


@label clearcell
	; value is the address to the front of the cell
	zero r8
	zero r7
	branch immediate storecell
@label loadcell
	memory load 0m1111 0x2 value r4
	memory load 0m1111 0x0 value value
	return

@label storecell
	memory store 0m1111 0x0 value r8
	memory store 0m1111 0x2 value r7
	return
	
@label unmarkgcbit
	logical and immediate 0m1111 value 0xFFFFFFFE
	return
@label markgcbit
	; mark the lowest most bit of a given dword
	logical or immediate 0m0001 value 0x1
	return

@label isgcbitset
	logical and immediate 0m0001 value 0x1
	compare == none immediate value 0x1
	return 

@label setintegertype
	logical and immediate 0m1111 value 0xFFFFFFFD
	return
@label isintegertype
	logical and immediate 0m0001 value 0x2
	compare == none immediate value 0x0
	return
@label setlisttype
	logical or immediate 0m1111 value 0x000000020
	return
@label islisttype
	logical and immediate 0m0001 value 0x2
	compare != none immediate value 0x0
	return

@label popParam
	; nothing to take in
	memory pop 0m1111 r4 r10
	return
@label pushParam
	; value - what to push onto the stack
	memory push 0m1111 value r10
	return
	
@label integer_cell
	shift left immediate value 0x2
	return
@label Print_OutOfMemory
	branch immediate terminate
@label OutOfMemory
	set 0m1111 r4 NIL
	compare == none addr r4
	return
@label GetMemoryCell
	; need to get a cell from the available list
	branch call immediate OutOfMemory
	branch cond immediate PerformGC
	branch immediate GetMemoryCell_DONE
@label PerformGC
	;branch call immediate GC
	branch call immediate OutOfMemory
	branch cond immediate Print_OutOfMemory
@label GetMemoryCell_DONE
	; grab the cell's address
	memory load 0m1111 0x0 addr value	; load the car into value for returning
	memory load 0m1111 0x2 addr addr    ; pop this element off the list
	return

@label ShouldGarbageCollect
	; inspect the target address to see if the corresponding pair should be garbage collected
	; value - the address to check
	move 0m0001 r4 value
	logical and immediate 0m0001 r4 0x1
	compare > none immediate r4 0x0
	return

@label car
	memory load 0m1111 0x0 value r4
	return
@label cdr
	memory load 0m1111 0x2 value r4
	return
;@label allocateMemoryCell
;	branch call immediate outOfMemory
;	branch cond immediate isOutOfMemory
;	; not out of memory
;	memory load 0m1111 0x0 addr value ; load the car into value
;	memory load 0m1111 0x2 addr addr   ; load the cdr into addr
;	branch immediate loadMemoryCell_Done
;@label isOutOfMemory
;	branch call immediate garbageCollect
;@label loadMemoryCell_Done
;	return
;@label garbageCollect
;	; TODO: implement
;	return
	
@label nilp
	set 0m1111 r4 0x007FFFFC
	compare == none value r4
	return
@org 0x00400000
@label stackBottom
@org 0x00600000
@label paramBottom
@org 0x006FFFFC
@label freeListBegin
@org 0x007FFFFC
@label freeListEnd
@label NIL
	@dword 0xFF7FFFFC
	@dword NIL
@label MemoryStart
@org 0x00FFFFFC
@label MemoryEnd
