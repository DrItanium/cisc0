; Need to setup the initial program load of the machine
; no need to ever save r9! You should only use it in leaf functions!
@org 0x00100000
	@label GC
		set 0m1111 r9 paramBottom
		memory push 0m1111 r9 r10
		memory push 0m1111 r10 r10
		set 0m1111 r9 reclaimMemory
		memory push 0m1111 r9
		branch immediate markStack
	@label markCell_CheckPointer
		memory push 0m1111 r0
			memory pop 0m1111 r0 r10
			memory push 0m1111 r0 r10
			branch call immediate isgcbitset
			branch cond immediate markCell_CheckPointer_Done
			memory push 0m1111 r0 r10
			branch call immediate integerp_without_conversion
			branch cond immediate markCell_CheckPointer_Done
			logical and immediate 0m1111 r0 0x00FFFFFC
			memory push 0m1111 r0 r10
			branch call immediate markCell
		memory pop 0m1111 r0
		return

		memory pop 0m1111 r0
		return
	@label markCell
		; arg0 base pointer
		memory push 0m1111 r0
		memory push 0m1111 r1
			memory pop 0m1111 r0 r10
			memory load 0m1111 0x0 r0 r1
			memory push 0m1111 r1 r10
			branch call immediate markCell_CheckPointer
			memory load 0m1111 0x2 r0 r1
			memory push 0m1111 r1 r10
			branch call immediate markCell_CheckPointer
		memory pop 0m1111 r1
		memory pop 0m1111 r0
		return
	@label markStack
		memory push 0m1111 r0
		memory push 0m1111 r1
		memory push 0m1111 r2
			memory pop 0m1111 r0 r10
			memory pop 0m1111 r1 r10
			@label markStackLoop
				compare >= none r0 r1
				branch cond immediate markStackLoop_Done
				memory load 0m1111 0x0 r0 r2
				branch call immediate integerp
				branch cond immediate markStackLoop_Iterate
				logical and immediate 0m1111 r2 0x00FFFFFC
				memory push 0m1111 r2 r10
				branch call immediate markCell
				@label markStackLoop_Iterate
					arithmetic add immediate r0 0x4
					branch immediate markStackLoop
		@label markStackLoop_Done
		memory pop 0m1111 r2
		memory pop 0m1111 r1
		memory pop 0m1111 r0
		return

	@label reclaimMemory
		memory push 0m1111 r0
		memory push 0m1111 r1
		memory push 0m1111 r2
		memory push 0m1111 r3
			set 0m1111 r0 MemoryBegin
			set 0m1111 r1 MemoryEnd
			@label reclaimMemory_Loop
				compare > none r0 r1
				branch cond immediate reclaimMemory_Done
				memory load 0m1111 0x0 r0 r2
				memory push 0m1111 r2 r10
				; TODO continue 
		@label reclaimMemory_Done
		memory pop 0m1111 r3
		memory pop 0m1111 r2
		memory pop 0m1111 r1
		memory pop 0m1111 r0
		return
    ; Several handler routines
    @label systemConstants
        @dword stackBottom
        @dword paramBottom
        @dword freeListEnd
        @dword NIL
        @dword MemoryBegin
        @dword MemoryEnd
    @label IsOutOfMemory
        memory push 0m1111 r0
        set 0m1111 r0 NIL
        compare == none addr r0
        memory pop 0m11111 r0
        return
    @label StackUnderflow
        ; TODO: printout system error message!
    @label CompletelyOutOfMemory
        ; TODO: implement the out of memory message!
    @label terminate
        system 0 value

@org 0x00400000
    @label stackBottom
@org 0x00600000
    @label paramBottom
@org 0x006FFFFC
    @label freeListBegin
@org 0x007FFFFC
    @label freeListEnd
    @label NIL
        @dword 0xFF7FFFFC
        @dword NIL
    @label MemoryBegin
@org 0x00FFFFFC
    @label MemoryEnd

@org 0x00000000
    set 0m1111 sp stackBottom  ; first setup the internal stack
    set 0m1111 r10 paramBottom ; then setup the parameter stack
    set 0m1111 r0 StackUnderflow ; We should never ever get to this function !
    memory push 0m1111 r0 sp  
    set 0m1111 r0 Eval         ; goto the eval function
    memory push 0m1111 r0 sp   ; push the eval function onto the stack
    set 0m1111 r0 MemoryEnd
    memory push 0m1111 r0 r10  ; we want memory end to be the bottom of the stack
    set 0m1111 r0 MemoryBegin  
    memory push 0m1111 r0 r10  ; then the beginning of memory
    set 0m1111 r0 NIL          
    memory push 0m1111 r0 r10  ; then the beginning of the free list
    branch immediate startup
@label startup
    ; initialize the runtime of the system
    memory pop 0m1111 addr r10
    memory pop 0m1111 r0 r10
    memory pop 0m1111 r1 r10
    @label startup_memory_init
        compare > none r0 r1    ; keep going until r0 is greater than r1
        branch cond immediate setup_memory_init_done
        memory push 0m1111 r0 addr
        arithmetic add immediate r0 0x4
        branch immediate startup_memory_init
    @label setup_memory_init_done
        return
@label terminate
    system 0 value
@label param_pop
    memory pop 0m1111 value r10
    return
@label param_push
    memory push 0m1111 value r10
    return
@label make_integer
    memory push 0m1111 value 
        memory pop 0m1111 value r10
        shift left immediate value 0x2      ; shift left by 2 to start the tagging process
        arithmetic add immediate value 0x2  ; this is an integer tagged value
        memory push 0m1111 value r10
    memory pop 0m1111 value
    return
@label hash_character
    memory push 0m1111 r0
    memory push 0m1111 r1
    memory push 0m1111 value
    memory pop 0m1111 value r10
    memory pop 0m1111 r0 r10
    set 0m0001 r1 0x1
    ; super expensive but right now I'm just implementing it
    @label hash_character_loop
        compare == none immediate r0 0x0
        branch cond immediate hash_character_loop_done
        arithmetic mul immediate r1 13
        decrement r0
        branch immediate hash_character_loop
    @label hash_character_loop_done
        arithmetic mul value r1             ; perform the combination action
        memory push 0m1111 value r10        ; now we need to tag it as an integer
        branch call immediate make_integer
    memory pop 0m1111 value
    memory pop 0m1111 r1
    memory pop 0m1111 r0
    return
@label hash_string
    memory push 0m1111 r0
    memory push 0m1111 r1
    memory push 0m1111 r2
    memory push 0m1111 r3
    memory push 0m1111 value
    zero r2
    zero r0
    zero r3
    memory pop 0m1111 r1 r10
    @label hash_string_loop
        memory load 0m1111 0x0 r1 r2
        compare == none immediate r2 0x0
        branch cond immediate hash_string_done
        memory push 0m1111 r0 r10
        memory push 0m1111 r2 r10
        branch call immediate hash_character
        memory pop 0m1111 value r10
        arithmetic add r3 value
        increment r1
        increment r0
        branch immediate hash_string_loop
    @label hash_string_done
        memory push 0m1111 r3 r10
    memory pop 0m1111 value
    memory pop 0m1111 r3
    memory pop 0m1111 r2
    memory pop 0m1111 r1
    memory pop 0m1111 r0
@label getMemoryCell
    memory push 0m1111 r0
    branch call immediate IsOutOfMemory
    branch cond immediate PerformGC
    branch immediate GetMemoryCell_DONE
    @label PeformGC
        branch call immediate GC
        branch call immediate OutOfMemory
        branch cond immediate CompletelyOutOfMemory ; We're done, no more memory!
    @label GetMemoryCell_DONE
        memory pop 0m1111 r0 addr       ; transfer the new memory cell to the parameter stack for usage
        memory push 0m1111 r0 r10       ; 
    memory pop 0m1111 r0
    return
@label cons
    memory push 0m1111 r0
    memory push 0m1111 r1
        branch call immediate getMemoryCell
        memory pop 0m1111 r1 r10        ; new memory cell from the getMemoryCell call
                                        ; store the two elements
        memory pop 0m1111 r0 r10        ; car
        memory store 0m1111 0x0 r0 r1
        memory pop 0m1111 r0 r10        ; cdr
        memory store 0m1111 0x2 r0 r1
        memory push 0m1111 r1 r10
    memory pop 0m1111 r1
    memory pop 0m1111 r0
    return
@label car
    memory pop 0m1111 r9 r10
    memory load 0m1111 0x0 r9 r9 ; we don't really care about this chicanery
    memory push 0m1111 r9 r10
    return
@label cdr
    memory pop 0m1111 r9 r10
    memory load 0m1111 0x2 r9 r9 
    memory push 0m1111 r9 r10
    return
; manipulate the call stack to do the operations via returns :)
@label cadr
    set 0m1111 r9 car
    memory push 0m1111 r9
    branch immediate cdr
@label caddr
    set 0m1111 r9 car
    memory push 0m1111 r9
    set 0m1111 r9 cdr
    memory push 0m1111 r9
    branch immediate cdr
@label cdar
    set 0m1111 r9 cdr
    memory push 0m1111 r9
    branch immediate car

@label to_condition_register
    ; check and see if we're looking at NIL, if we are then it is FALSE
    memory pop 0m1111 r9 r10
    logical xor immediate 0m1111 r9 NIL
    compare != none immediate r9 0x0
    return

@label convert_boolean
    ; convert the cr value to either NIL or 0x00FFFF
    branch cond immediate convert_boolean_true
        set 0m1111 r9 NIL
        branch push_to_stack
    @label convert_boolean_true
        set 0m0111 r9 0x00FFFFFD
    @label push_to_stack
        memory push 0m1111 r9 r10
        return
@label listp
    set 0m1111 r9 convert_boolean
    memory push 0m1111 r9
@label listp_without_conversion
    memory pop 0m1111 r9 r10
    logical and immediate 0m1001 r9 0xFF000002
    compare == none immediate r9 0x2            ; the upper most 8 bits must be cleared!
    return
@label integerp
    set 0m1111 r9 convert_boolean
    memory push 0m1111 r9
@label integerp_without_conversion
    memory pop 0m1111 r9 r10
    logical and immediate 0m0001 r9 0x2
    compare == none immediate r9 0x0
    return
@label dup
    memory load 0m1111 0x0 r10 r9
    memory push 0m1111 r9 r10
    return
@label atomp
    branch call immediate dup
    branch call immediate integerp_without_conversion
    branch cond immediate is_atom_pop
    branch call immediate listp_without_conversion
    branch cond immediate is_not_atom
    branch immediate is_atom
    @label is_atom_pop
        memory pop 0m1111 r9 r10    ; pop the duplicated element off the stack since we don't need it
    @label is_atom
        set 0m0111 r9 0x00FFFF
        branch immediate atomp_done
    @label is_not_atom
        set 0m1111 r9 NIL
    @label atomp_done
        memory push 0m1111 r9 r10
        return

@label Eval
    
