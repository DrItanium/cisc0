; iris16 instruction decoders
@label Iris16Loop
	branch call immediate LoadInstructionPointer ; Load the instruction pointer
	branch call immediate LoadCodeAddress        ; Combine it with the code address offset
	move 0m1111 addr value                       ; put the loaded instruction to addr
	branch call immediate DecodeGroup            ;
	move 0m0001 r0 value                         ; store the group in r0
	branch call immediate DecodeOperation        ;
	move 0m0001 r1 value                         ; store the operation in r1
	branch call immediate DecodeDestination      ;
	move 0m0001 r2 value                         ; store the destination index
	branch call immediate DecodeSource0          ;
	move 0m0001 r3 value
	branch call immediate DecodeSource1
	move 0m0001 r4 value
	branch call immediate DecodeImmediate
	move 0m0011 r5 value
	branch call immediate DispatchInstruction
	; TODO: implement advance ip check
	branch call immediate TryAdvanceIp
	set 0m1111 addr Iris16_Fields
	memory load 0m0011 0x0
	compare == none immediate value 0x00
	branch cond immediate Iris16Shutdown
	branch immediate Iris16Loop
@label Iris16Shutdown
	zero addr
	system r0 ; bye bye :)
@constant 0x1 ?true
@constant 0x0 ?false
@constant 0x0 ?execute
@constant 0x1 ?advanceIp
@constant 0xFF ?pc

@label LoadRegister
	set 0m1111 addr Iris16Registers     ; set the base address to the register offset
	arithmetic add addr value           ; combine the base address with the register offset
	memory load 0m0011 0x0              ; Load it into the value register
	return

@label StoreRegister
	; r8 - the register index
	; value - the value to store
	set 0m1111 addr Iris16Registers     ; set the base address to the register offset
	arithmetic add addr r8              ; combine with the register index
	memory store 0m0011 0x0             ; Store the value into the register
	return

@label LoadDataAddress
	set 0m1111 addr Iris16Data
	arithmetic add addr value
	memory load 0m0011 0x0
	return

@label StoreDataAddress
	; r8 - offset
	; value - the value to store
	set 0m1111 addr Iris16Data
	arithmetic add addr r8
	memory store 0m0011 0x0
	return

@label LoadCodeAddress
	set 0m1111 addr Iris16Code			; Load the base address offset
	arithmetic add addr value           ; Add the actual immediate value
	memory load 0m1111 0x0              ; load from memory
	return

@label StoreCodeAddress
	; r8 - the offset of the address
	; value - what to store
	set 0m1111 addr Iris16Code       ; load the base address offset
	arithmetic add addr r8           ; add the offset to the address
	memory store 0m1111 0x0			 ; Store the value
	return


@label TryAdvanceIp
	memory push 0m1111 lr
	set 0m1111 addr Iris16_Fields                     ; Load the base fields offset
	memory load 0m0011 ?advanceIp                     ; Load the advance ip field
	compare != none immediate value ?false            ; Is the advanceip field is false?
	branch cond immediate TryAdvanceIpDone            ; If not then just leave
	branch call immediate IncrementInstructionPointer ; Advance the ip
	set 0m0011 value ?true                            ; set the advance ip field to true
	memory store 0m0011 ?advanceIp                    ; set advance ip
@label TryAdvanceIpDone
	memory pop 0m1111 lr
	return

@label IncrementInstructionPointer
	memory push 0m1111 lr
	branch call immediate LoadInstructionPointer
	increment value
	branch call immediate StoreInstructionPointer
	memory pop 0m1111 lr
	return

@label StoreInstructionPointer
	set 0m0001 r8 ?pc
	branch immediate StoreRegister

@label LoadInstructionPointer
	set 0m0001 value ?pc
	branch immediate LoadRegister

@label BaseDecode
	complex encoding decode
	return
@label DecodeDestination
	set 0m1111 mask 0x0000FF00
	set 0m0001 shift_width 8
	branch immediate BaseDecode

@label DecodeSource0
	set 0m1111 mask 0x00FF0000
	set 0m0001 shift_width 16
	branch immediate BaseDecode

@label DecodeHalfImmediate
@label DecodeSource1
	set 0m1111 mask 0xFF000000
	set 0m0001 shift_width 24
	branch immediate BaseDecode

@label DecodeImmediate
	set 0m1111 mask 0xFFFF0000
	set 0m0001 shift_width 16
	branch immediate BaseDecode

@label DecodeGroup
	set 0m0001 mask 0x00000007
	zero shift_width
	branch immediate BaseDecode

@label DecodeOperation
	set 0m1111 mask 0x000000F8
	set 0m0001 shift_width 3
	branch immediate BaseDecode

@label DispatchInstruction
    memory push 0m1111 lr
    memory push 0m1111 addr
    set 0m1111 addr GroupBase           ; get the base offset of the group value
    arithmetic add addr r0              ; Add the group to the group base
    memory load 0m1111 0x0              ; Load the actual address of the group function
    move 0m1111 addr value              ; load the jump target into addr
    branch call immediate EnterFunction ; Call the indirect function call
    memory pop 0m1111 addr
    memory pop 0m1111 lr
	return

@label EnterFunction
    memory push 0m1111 lr
    branch addr
@label Done
    memory pop 0m1111 lr
    return
@label LoadFunctionOffset
    set 0m1111 addr BaseTableAddresses   ; get the base table offset
    arithmetic add addr r0               ; add the group offset
    memory load 0m1111 0x0               ; load that base address from memory
    move 0m1111 addr value               ; move that address to the address register
    arithmetic add addr r1               ; add to the corresponding add the operation to it
    memory load 0m1111 0x0               ; load that address from the secondary offset
    return

@label ResolveRegisters
    ; load source0
    move 0m0011 value r3
    branch call immediate LoadRegister
    move 0m0011 r6 value
    ; load source1
    move 0m0011 value r4
    branch call immediate LoadRegister
    move 0m0011 r7 value
    return

@label ArithmeticOp
    ; load source0 into r6
    branch call immediate ResolveRegisters
    ; load the micro routine to invoke
    branch call immediate LoadFunctionOffset
    move 0m1111 r8 value
    move 0m0011 value r6    ; Set value to r6 (makes computation easier)
    branch call r8          ; call the operation itself
                            ; now we act to store the given value into the destination register
    move 0m0011 r8 r2       ; Move r2 into r8 to start the store process
                            ; Value already contains the result of calling r8
    branch call immediate StoreRegister
    branch immediate Done


@label Add
    arithmetic add value r7
    return
@label Sub
    arithmetic sub value r7
    return
@label Mul
    arithmetic mul value r7
    return
@label Div
    arithmetic div value r7
    return
@label Rem
    arithmetic rem value r7
    return
@label ShiftLeft
    shift left value r7
    return
@label ShiftRight
    shift right value r7
    return
@label BinaryAnd
    logical and value r7
    return
@label BinaryOr
    logical or value r7
    return
@label BinaryNot
    logical not value
    return
@label BinaryXor
    logical xor value r7
    return
@label AddImmediate
    arithmetic add value r5
    return
@label SubImmediate
    arithmetic sub value r5
    return
@label MulImmediate
    arithmetic mul value r5
    return
@label DivImmediate
    arithmetic div value r5
    return
@label RemImmediate
    arithmetic rem value r5
    return
@label ShiftLeftImmediate
    shift left value r5
    return
@label ShiftRightImmediate
    shift right value r5
    return

@label JumpOp
    branch immediate Done
@label CompareOp
    branch immediate Done
@label MiscOp
    branch immediate Done
@label SystemCall
    ; @TODO continue
    return
; TODO: finish move operations, they are quite different
@label MoveOp
    ; load source0 into r6
    branch call immediate ResolveRegisters
    ; load the micro routine to invoke
    branch call immediate LoadFunctionOffset
    move 0m1111 r8 value
    move 0m0011 value r6    ; Set value to r6 (makes computation easier)
    branch call r8          ; call the operation itself
                            ; now we act to store the given value into the destination register
    move 0m0011 r8 r2       ; Move r2 into r8 to start the store process
                            ; Value already contains the result of calling r8
    branch call immediate StoreRegister
    branch immediate Done
@label Move
	branch immediate Done ; don't do anything else
@label Set
	move 0m0011 value r5
	branch immediate Done
@label Swap
	branch immediate Done
@label Load
	branch immediate Done
@label LoadImmediate
	branch immediate Done
@label Store
	branch immediate Done
@label Memset
	branch immediate Done
@label Push
	branch immediate Done
@label PushImmediate
	branch immediate Done
@label Pop
	branch immediate Done
@label LoadCode
	branch immediate Done
@label StoreCode
	branch immediate Done
; Jump Table
@label GroupBase
    @dword ArithmeticOp
    @dword MoveOp
    @dword JumpOp
    @dword CompareOp
    @dword MiscOp
@label BaseTableAddresses
    @dword ArithmeticBase
    @dword MoveBase
    @dword JumpBase
    @dword CompareBase
    @dword MiscBase
@label ArithmeticBase
    @dword Add
    @dword Sub
    @dword Mul
    @dword Div
    @dword Rem
    @dword ShiftLeft
    @dword ShiftRight
    @dword BinaryAnd
    @dword BinaryOr
    @dword BinaryNot
    @dword BinaryXor
    @dword AddImmediate
    @dword SubImmediate
    @dword MulImmediate
    @dword DivImmediate
    @dword RemImmediate
    @dword ShiftLeftImmediate
    @dword ShiftRightImmediate
@label MoveBase
	@dword Move
	@dword Set
	@dword Swap
	@dword Load
	@dword LoadImmediate
	@dword Store
	@dword Memset
	@dword Push
	@dword PushImmediate
	@dword Pop
	@dword LoadCode
	@dword StoreCode
@label JumpBase
	@dword UnconditionalImmediate
	@dword UnconditionalImmediateLink
	@dword UnconditionalRegister
	@dword UnconditionalRegisterLink
	@dword ConditionalTrueImmediate
	@dword ConditionalTrueImmediateLink
	@dword ConditionalTrueRegister
	@dword ConditionalTrueRegisterLink
	@dword ConditionalFalseImmediate
	@dword ConditionalFalseImmediateLink
	@dword ConditionalFalseRegister
	@dword ConditionalFalseRegisterLink
	@dword IfThenElseNormalPredTrue
	@dword IfThenElseNormalPredFalse
	@dword IfThenElseLinkPredTrue
	@dword IfThenElseLinkPredFalse 
@label CompareBase
	@dword Eq
	@dword EqImm
	@dword Neq
	@dword NeqImm
	@dword LessThan
	@dword LessThanImm
	@dword GreaterThan
	@dword GreaterThanImm
	@dword LessThanOrEqualTo
	@dword LessThanOrEqualToImm
	@dword GreaterThanOrEqualTo
	@dword GreaterThanOrEqualToImm
@label MiscBase
	@dword SystemCall
; memory and register declarations
@org 0xFB0000
@label Iris16Code
@org 0xFD0000
@label Iris16Data
@org 0xFE0000
@label Iris16Stack
@org 0xFF0000
@label Iris16StackEnd
@label Iris16_Fields
@label Iris16_Execute
@word 0x0001
@label Iris16_AdvanceIp
@word 0x0001
@org 0xFFFF00
@label Iris16Registers
