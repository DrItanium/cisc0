; iris16 instruction decoders
@constant 0x1 ?true
@constant 0x0 ?false
@constant 0x0 ?execute
@constant 0x1 ?advanceIp
@constant 0xFF ?pc
@constant 0xFE ?sp
@constant 0xFD ?lr
@label Iris16Startup
@label Iris16Loop
	branch call immediate LoadInstruction        ; Load an instruction from code memory
	move 0m1111 addr value                       ; put the loaded instruction to addr
	branch call immediate DecodeGroup            ;
	move 0m0001 r0 value                         ; store the group in r0
	branch call immediate DecodeOperation        ;
	move 0m0001 r1 value                         ; store the operation in r1
	branch call immediate DecodeDestination      ;
	move 0m0001 r2 value                         ; store the destination index
	branch call immediate DecodeSource0          ;
	move 0m0001 r3 value
	branch call immediate DecodeSource1
	move 0m0001 r4 value
	branch call immediate DecodeImmediate
	move 0m0011 r5 value
	branch call immediate DispatchInstruction
	branch call immediate TryAdvanceIp
	set 0m1111 addr Iris16_Fields
	memory load 0m0011 ?execute
	compare == none immediate value 0x00
	branch cond immediate Iris16Shutdown
	branch immediate Iris16Loop
@label Iris16Shutdown
	zero addr
	system r0 ; bye bye :)


@label PushOntoStack
	memory push 0m1111 value						; Save the value we want to store
	branch call immediate IncrementStackPointer		; we'll get the new stack pointer by side effect of incrementing it
	memory pop 0m1111 value							; restore the original value
	branch call immediate StoreStackTop				; save to the top of the stack
	return

@label PopFromStack
	branch call immediate LoadStackTop				; Load the top of the stack from memory
	memory push 0m1111 value						; Save this new value to the stack
	branch call immediate DecrementStackPointer		; Decrement the stack pointer
	memory pop 0m1111 value							; restore the value
	return

@label LoadStackTop
	branch call immediate LoadStackPointer	; need SP so make the call to get it into value
	set 0m1111 addr Iris16Stack				; Load the base stack address
	branch immediate Load16bitValue			; Load the corresponding stack value
@label LoadDataAddress
	set 0m1111 addr Iris16Data
	branch immediate Load16bitValue
@label LoadStackPointer
	set 0m0001 value ?sp				; load the stack pointer index
	branch immediate LoadRegister
@label LoadInstructionPointer
	set 0m0001 value ?pc				; Set the index to ?pc and exploit fallthrough
@label LoadRegister
	set 0m1111 addr Iris16Registers     ; set the base address to the register offset
@label Load16bitValue
	arithmetic add addr value           ; combine the base address with the register offset
	memory load 0m0011 0x0              ; Load it into the value register
	return

@label StoreStackTop
	memory push 0m1111 value
	branch call immediate LoadStackPointer
	move 0m1111 r8 value					; load the offset into r8
	memory pop 0m1111 value					; restore the value to store
	set 0m1111 addr Iris16Stack				; set the addr to the stack base
	branch immediate Store16bitValue		; store it
@label StoreDataAddress
	; r8 - offset
	; value - the value to store
	set 0m1111 addr Iris16Data
	branch immediate Store16bitValue
@label StoreStackPointer
	set 0m0001 r8 ?sp                   ; We want to store the stack pointer value
	branch immediate StoreRegister
@label StoreInstructionPointer
	set 0m0001 r8 ?pc					; Set the offset to the ?pc "register" and exploit fallthrough
@label StoreRegister
	; r8 - the register index
	; value - the value to store
	set 0m1111 addr Iris16Registers     ; set the base address to the register offset
@label Store16bitValue
	arithmetic add addr r8              ; combine with the register index
	memory store 0m0011 0x0             ; Store the value into the register
	return

@label LoadInstruction
	branch call immediate LoadInstructionPointer     ; Get the ip address as seen by iris16
	shift left immediate value 0x1                   ; Shift the ip address by 1 to make sure that the address is always even 
													 ; exploit fallthrough
@label LoadCodeAddress
	set 0m1111 addr Iris16Code						 ; Load the base address offset
@label Load32bitValue 
	arithmetic add addr value           			 ; Add the actual immediate value
	memory load 0m1111 0x0              			 ; load from memory
	return

@label StoreInstruction
	; r8 - the offset of the address
	; value - the instruction to encode
	shift left immediate r8 0x1			; Shift left by one to take the 32bit instruction nature into account
										; exploit fallthrough
@label StoreCodeAddress
	; r8 - the offset of the address
	; value - what to store
	set 0m1111 addr Iris16Code       	; load the base address offset
@label Store32bitValue
	arithmetic add addr r8           	; add the offset to the address
	memory store 0m1111 0x0			 	; Store the value
	return


@label TryAdvanceIp
	set 0m1111 addr Iris16_Fields                     ; Load the base fields offset
	memory load 0m0011 ?advanceIp                     ; Load the advance ip field
	compare != none immediate value ?false            ; Is the advanceip field is false?
	branch cond immediate TryAdvanceIpDone            ; If not then just leave
	branch call immediate IncrementInstructionPointer ; Advance the ip
	set 0m0011 value ?true                            ; set the advance ip field to true
	memory store 0m0011 ?advanceIp                    ; set advance ip
@label TryAdvanceIpDone
	return

@label IncrementInstructionPointer
	; Increment the ip register by one as seen by iris16.
	; The shift to convert it to iris18 is not needed.
	branch call immediate LoadInstructionPointer	; Load the ip address as seen by iris16
	increment value									; Increment it by one
	branch immediate CommitInstructionPointer
@label DecrementInstructionPointer
	branch call immediate LoadInstructionPointer
	decrement value
@label CommitInstructionPointer
	branch call immediate StoreInstructionPointer   ; Store the result
	return											; and we're done :)

@label IncrementStackPointer
	branch call immediate LoadStackPointer
	increment value
	branch immediate CommitStackPointer
@label DecrementStackPointer 
	branch call immediate LoadStackPointer
	decrement value
@label CommitStackPointer
	branch call immediate StoreStackPointer
	return




@label DecodeDestination
	set 0m1111 mask 0x0000FF00
	set 0m0001 shift_width 8
	branch immediate BaseDecode
@label DecodeSource0
	set 0m1111 mask 0x00FF0000
	set 0m0001 shift_width 16
	branch immediate BaseDecode
@label DecodeHalfImmediate
@label DecodeSource1
	set 0m1111 mask 0xFF000000
	set 0m0001 shift_width 24
	branch immediate BaseDecode
@label DecodeImmediate
	set 0m1111 mask 0xFFFF0000
	set 0m0001 shift_width 16
	branch immediate BaseDecode
@label DecodeOperation
	set 0m1111 mask 0x000000F8
	set 0m0001 shift_width 3
	branch immediate BaseDecode
@label DecodeGroup
	set 0m0001 mask 0x00000007
	zero shift_width
@label BaseDecode
	complex encoding decode
	return

@label DispatchInstruction
    memory push 0m1111 addr
    set 0m1111 addr GroupBase            ; get the base offset of the group value
	branch call immediate Load32bitValue ; Load the 32bit address
    arithmetic add addr r0               ; Add the group to the group base
    memory load 0m1111 0x0               ; Load the actual address of the group function
	branch call value 					 ; Branch to the address described in memory
    memory pop 0m1111 addr
	return

@label EnterFunction
    branch addr
@label LoadFunctionOffset
    set 0m1111 addr BaseTableAddresses   ; get the base table offset
    arithmetic add addr r0               ; add the group offset
    memory load 0m1111 0x0               ; load that base address from memory
    move 0m1111 addr value               ; move that address to the address register
    arithmetic add addr r1               ; add to the corresponding add the operation to it
    memory load 0m1111 0x0               ; load that address from the secondary offset
    return

@label ResolveRegisters
    ; load source0
    move 0m0011 value r3
    branch call immediate LoadRegister
    move 0m0011 r6 value
    ; load source1
    move 0m0011 value r4
    branch call immediate LoadRegister
    move 0m0011 r7 value
    return

@label ArithmeticOp
    ; load source0 into r6
    branch call immediate ResolveRegisters
    ; load the micro routine to invoke
    branch call immediate LoadFunctionOffset
    move 0m1111 r8 value
    move 0m0011 value r6    ; Set value to r6 (makes computation easier)
    branch call r8          ; call the operation itself
                            ; now we act to store the given value into the destination register
    move 0m0011 r8 r2       ; Move r2 into r8 to start the store process
                            ; Value already contains the result of calling r8
    branch call immediate StoreRegister
	return


@label Add
    arithmetic add value r7
    return
@label Sub
    arithmetic sub value r7
    return
@label Mul
    arithmetic mul value r7
    return
@label Div
    arithmetic div value r7
    return
@label Rem
    arithmetic rem value r7
    return
@label ShiftLeft
    shift left value r7
    return
@label ShiftRight
    shift right value r7
    return
@label BinaryAnd
    logical and value r7
    return
@label BinaryOr
    logical or value r7
    return
@label BinaryNot
    logical not value
    return
@label BinaryXor
    logical xor value r7
    return
@label AddImmediate
    arithmetic add value r5
    return
@label SubImmediate
    arithmetic sub value r5
    return
@label MulImmediate
    arithmetic mul value r5
    return
@label DivImmediate
    arithmetic div value r5
    return
@label RemImmediate
    arithmetic rem value r5
    return
@label ShiftLeftImmediate
    shift left value r5
    return
@label ShiftRightImmediate
    shift right value r5
    return

@label JumpOp
    return
@label CompareOp
    return
@label MiscOp
    return
@label SystemCall
    ; @TODO continue
    return
; TODO: finish move operations, they are quite different
@label MoveOp
    ; load source0 into r6
    branch call immediate ResolveRegisters
    ; load the micro routine to invoke
    branch call immediate LoadFunctionOffset
    move 0m1111 r8 value
    move 0m0011 value r6    ; Set value to r6 (makes computation easier)
    branch call r8          ; call the operation itself
                            ; now we act to store the given value into the destination register
    move 0m0011 r8 r2       ; Move r2 into r8 to start the store process
                            ; Value already contains the result of calling r8
    branch call immediate StoreRegister
    return
@label Move
	return ; don't do anything else
@label Set
	move 0m0011 value r5
	return
@label Swap
	return
@label Load
	return
@label LoadImmediate
	return
@label Store
	return
@label Memset
	return
@label Push
	return
@label PushImmediate
	return
@label Pop
	return
@label LoadCode
	return
@label StoreCode
	return
; Jump Table
@label GroupBase
    @dword ArithmeticOp
    @dword MoveOp
    @dword JumpOp
    @dword CompareOp
    @dword MiscOp
@label BaseTableAddresses
    @dword ArithmeticBase
    @dword MoveBase
    @dword JumpBase
    @dword CompareBase
    @dword MiscBase
@label ArithmeticBase
    @dword Add
    @dword Sub
    @dword Mul
    @dword Div
    @dword Rem
    @dword ShiftLeft
    @dword ShiftRight
    @dword BinaryAnd
    @dword BinaryOr
    @dword BinaryNot
    @dword BinaryXor
    @dword AddImmediate
    @dword SubImmediate
    @dword MulImmediate
    @dword DivImmediate
    @dword RemImmediate
    @dword ShiftLeftImmediate
    @dword ShiftRightImmediate
@label MoveBase
	@dword Move
	@dword Set
	@dword Swap
	@dword Load
	@dword LoadImmediate
	@dword Store
	@dword Memset
	@dword Push
	@dword PushImmediate
	@dword Pop
	@dword LoadCode
	@dword StoreCode
@label JumpBase
	@dword UnconditionalImmediate
	@dword UnconditionalImmediateLink
	@dword UnconditionalRegister
	@dword UnconditionalRegisterLink
	@dword ConditionalTrueImmediate
	@dword ConditionalTrueImmediateLink
	@dword ConditionalTrueRegister
	@dword ConditionalTrueRegisterLink
	@dword ConditionalFalseImmediate
	@dword ConditionalFalseImmediateLink
	@dword ConditionalFalseRegister
	@dword ConditionalFalseRegisterLink
	@dword IfThenElseNormalPredTrue
	@dword IfThenElseNormalPredFalse
	@dword IfThenElseLinkPredTrue
	@dword IfThenElseLinkPredFalse 
@label CompareBase
	@dword Eq
	@dword EqImm
	@dword Neq
	@dword NeqImm
	@dword LessThan
	@dword LessThanImm
	@dword GreaterThan
	@dword GreaterThanImm
	@dword LessThanOrEqualTo
	@dword LessThanOrEqualToImm
	@dword GreaterThanOrEqualTo
	@dword GreaterThanOrEqualToImm
@label MiscBase
	@dword SystemCall
; memory and register declarations
@org 0xFB0000
@label Iris16Code
@org 0xFD0000
@label Iris16Data
@org 0xFE0000
@label Iris16Stack
@org 0xFF0000
@label Iris16_Fields
@label Iris16_Execute
	@word 0x0001
@label Iris16_AdvanceIp
	@word 0x0001
@org 0xFFFF00
@label Iris16Registers
