; use the upper most registers (208-255) for kernel and backend stuff
; use registers 0-31 for globals
; use registers 32-63 for inputs
; use registers 64-95 for temporaries
; use registers 96-111 for returns
setl r243 thread_control_block_base	 ; load the thread control block base address
setu r243 thread_control_block_base	 ; 
muli r242 tid 4						 ; compute the offset
add r250 r243 r242					 ; combine it with the thread control block base and store it in the thread control base
addi r249 r250 2					 ; setup the stack pointer
ld sp r249							 ; load the stack pointer offset into memory
move r240 sp						 ; save a copy of the base stack pointer to r240
setl r249 0xFFFFFFFF 				 ; r249 is the thread invocation flag
setu r249 0xFFFFFFFF				 ;
setl r244 thread_idle				 ; Setup the thread_idle address
setu r244 thread_idle				 ;
@label thread_idle					 ; now, we are in the thread handler block
ld r248 r250						 ; load the evaluate jump field
addi r246 r250 1					 ; compute the offset for the jump address
ld r245 r246						 ; load it from memory
eq r247 r249 r248					 ; check to see if we should jump
jt r247 r245						 ; jump to address if the thread invocation flag is set to true
j r244

@label main_thread
setl r208 printstring
setu r208 printstring
setl r32 string ; address
setu r32 string
jl r208

setl r208 terminate_execution
setu r208 terminate_execution
j r208

@label terminate_execution
	system 0 r0 r0

@label printchar
	system 2 r32 r32
	ret

@label readchar
	system 1 r96 r96
	ret


@label printstring
	push lr
	push cr							; save the condition register
	push r64
	push r65
	push r66
	push r67
	move r64 r32 					; address cell
	setl r65 printstring_continue
	setu r65 printstring_continue
	setl r66 printstring_done
	setu r66 printstring_done
	setl r67 printchar
	setu r67 printchar
@label printstring_continue
	ld r32 r64
	nei cr r32 0
	jf cr r66
	jl r67 
	incr r64
	j r65
@label printstring_done
	pop r67
	pop r66
	pop r65
	pop r64
	pop cr
	pop lr
	ret

@label string
@word 0x46
@word 0x75
@word 0x63
@word 0x6B
@word 0x20
@word 0x79
@word 0x6F
@word 0x75
@word 0x20
@word 0x4D
@word 0x65
@word 0x6E
@word 0x64
@word 0x65
@word 0x7A
@word 0x2E
@word 0x0A
@word 0x46
@word 0x75
@word 0x63
@word 0x6B
@word 0x20
@word 0x79
@word 0x6F
@word 0x75
@word 0x20
@word 0x41
@word 0x69
@word 0x72
@word 0x65
@word 0x6E
@word 0x2E
@word 0x0A
@word 0x00


; stack data
@org 0x03F00000
@label thread0_stack_base
@org 0x03F10000
@label thread1_stack_base
@org 0x03F20000
@label thread2_stack_base
@org 0x03F30000
@label thread3_stack_base
@org 0x03F40000
@label thread4_stack_base
@org 0x03F50000
@label thread5_stack_base
@org 0x03F60000
@label thread6_stack_base
@org 0x03F70000
@label thread7_stack_base
; thread data
@org 0x03FF0000
; thread data structure
; 32-bits, evaluate jump
; 32-bits, address to jump to
; 32-bits, base stack pointer address
; 32-bits, unused
@label thread_control_block_base
@label thread0
@word 0xFFFFFFFF
@word main_thread
@word thread0_stack_base
@word 0x0

@label thread1
@word 0x00000000
@word thread_idle
@word thread1_stack_base
@word 0x0

@label thread2
@word 0x00000000
@word thread_idle
@word thread2_stack_base
@word 0x0

@label thread3
@word 0x00000000
@word thread_idle
@word thread3_stack_base
@word 0x0

@label thread4
@word 0x00000000
@word thread_idle
@word thread4_stack_base
@word 0x0

@label thread5
@word 0x00000000
@word thread_idle
@word thread5_stack_base
@word 0x0

@label thread6
@word 0x00000000
@word thread_idle
@word thread6_stack_base
@word 0x0

@label thread7
@word 0x00000000
@word thread_idle
@word thread7_stack_base
@word 0x0
