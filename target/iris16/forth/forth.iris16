;-----------------------------------------------------------------------------
; An implementation of the language specified by Charles H. Moore's book on
; a Problem orientied langauge.
;-----------------------------------------------------------------------------
; Fixed registers
;	- InstructionPoiner : r255 (aka ip)
;	- LinkRegister: r254 (aka lr)
;	- StackPointer: r253 (aka sp)
;	- Parameter Stack Top: r252 (aka ptop)
;	- Parameter Stack End: r251 (aka pend)
;	- Return Stack Top: r250 (aka rtop)
;	- Return Stack End: r249 (aka rend)
;	These are used internally for passing arguments around to leaf functions
;	- Safe Param 0: r248 (spar0)
;	- Safe Param 1: r247 (spar1)
;	- Safe Param 2: r246 (spar2)
;	- Safe Param 3: r245 (spar3)
;	- Safe Result 0: r244 (sres0)
;	- Safe Result 1: r243 (sres1)
;	- Safe Result 2: r242 (sres2)
;	- Safe Result 3: r241 (sres3)
;	- Safe Temporary 0: r240 (stmp0)
;	- Safe Temporary 1: r239 (stmp1)
;	- Safe Temporary 2: r238 (stmp2)
;	- Safe Temporary 3: r237 (stmp3)
;	- ASCII Space: r236 (space)
;	- Safe Temporary 4: r235 (stmp4)
;	- Safe Temporary 5: r234 (stmp5)
;	- Safe Temporary 6: r233 (stmp6)
;	- Max Word Length: r232 (wlen)
;	- Safe Temporary 7: r231 (stmp7)
;	- Zero register: r230 (zero)
;	- FETCH / DEPOSIT current: r229 (fdcur)
;	- input pointer: r228 (inptr)
;	- output pointer: r227 (outptr)
;	- is negative : r226
;	- nil registers : r225
;-----------------------------------------------------------------------------
; Parameter passing conventions
;  If the given subroutine calls another subroutine then you need to save
;  the current lr onto the return stack, otherwise you can just use it.
;  lr will always be populated in the case of subroutine calls
;-----------------------------------------------------------------------------
; setup the parameter and return stack pointers inside stack memory
;-----------------------------------------------------------------------------
; First setup the memory addresses using the org directive so that it is easy
; to keep track of
;-----------------------------------------------------------------------------
@data
@org 0xFFFF
	@label ParameterStackBottom ; this will make sure that 0x0000 is never wasted
@org 0x7FFF
	@label ReturnStackBottom
@org 0x0000
@code
@org 0x0000
; setup the initial values of the registers
set ptop ParameterStackBottom
set pend ParameterStackBottom
set rtop ReturnStackBottom
set rend ReturnStackBottom				 
set space 0x20							; fixed register for the ascii space code
set wlen 62								; the maximum number of characters allowed in a single word (- 1 for the terminator)

@label DONE								; top of our "control loop", what he calls RETURN
		set spar0 WORD_BUFFER				; load the front of the word buffer
		jl lr NUMBER						; check and see if we get a NUMBER from this input
		move stmp1 sres1					; extract the result field
		jf stmp1 PARSE_WORD					; 
		move stmp0 sres0					; extract the number field
		j PRINT_RESULT
	@label PARSE_WORD 
		set spar0 WORD_BUFFER				;
		jl lr WORD							; read the next word
	@label PRINT_RESULT
		jl lr print							; print it out
		set spar0 msg_newline				; 
		jl lr print							; print out a newline
		j DONE								; 
;-----------------------------------------------------------------------------
; Prints a string character by character until we see a \0
; Inputs:
;	spar0 - what to print out
;-----------------------------------------------------------------------------
@label print
	@label print_loop
		ld stmp0 spar0				; load the current char from memory into a register
		jf stmp0 print_done			; before printing, check to see that we should print, if it is zero then stop
		system 2 stmp0 stmp0		; print the character to the user
		addi spar0 spar0 1			; advance the index pointer to the next character
		j print_loop				; we're not done yet
	@label print_done
		jr lr						; return using the link register
;-----------------------------------------------------------------------------
; Treat the top of the stack as an address and loads its contents in place of
; the original address
;-----------------------------------------------------------------------------
@label AtVerb
	swap sp ptop 					; set the parameter stack as the current target
	pop stmp0						; get the top element
	ld stmp1 stmp0					; load, from memory, the data at the top of the stack
	push stmp1						; push the loaded value onto the stack
	swap sp ptop					; restore the previous value to the stack pointer and update ptop
	jr lr							; we're done here, go back
;-----------------------------------------------------------------------------
; Store second in memory at the address stored in top
;-----------------------------------------------------------------------------
@label EqualsVerb
	swap sp ptop					; load the top of the parameter stack
	pop stmp0						; get the top element (drop the element)
	pop stmp1 						; get the second element (drop the element)
	st stmp0 stmp1				; data[stmp0] = stmp1
	swap sp ptop					; restore the previous value and update ptop
									; TODO: put error checking here of the parameter stack
	jr lr							; we're done here!
;-----------------------------------------------------------------------------
; Takes in the offending word, an error message, prints them, then clears the
; stacks and then calls DONE.
; Inputs are on r32, r33 for this routine
;	spar0 - word that did a bad thing
;   spar1 - error type
;-----------------------------------------------------------------------------
@label ERROR								; Error routine
	move ptop pend 							; overwrite the current parameter stack location with the bottom
	move rtop rend							; overwrite the current return stack location with the bottom
	jl lr	print							; print the offending word that did the bad thing
	move spar0 spar1 						; now we need to print the error type so setup the arguments
	jl lr print								; and print it
	j DONE									; and we're done!
;-----------------------------------------------------------------------------
; SHUTDOWN / DIE - End the program and shutdown the machine
;-----------------------------------------------------------------------------
@label SHUTDOWN
@label DIE
	system 0, spar0, spar0


;-----------------------------------------------------------------------------
; WORD: Read the next word in the input
;	spar0 - pointer to temporary storage to save the current word
;-----------------------------------------------------------------------------
@label WORD
	move stmp2 spar0												; copy the pointer address to temporary storage so we can mess with it
	set	stmp3 WORD_read_data										; where to jump to if we see a space
	set	stmp4 WORD_reassign_jumps 									; where to jump to when wanting to handle storage
	set stmp5 0														; The number of characters in the word
	@label WORD_read_data											; Find all leading spaces and discard them
		system 1 stmp0 stmp0										; load the next character from input
		eq stmp1 stmp0 space 										; check and see if it is a space
		ift stmp1 stmp3 stmp4										; if we see a space then jump
																	; to stmp2 otherwise it is to
																	; stmp4. Initially this is
																	; setup to skip all prefixed
																	; spaces. Once a non-space has
																	; been seen then the jumps
																	; are reassigned to process (and store) 
																	; the word until we see another space
																	;
		@label WORD_reassign_jumps									; This should only be executed once!
			set stmp3 WORD_done_reading								; terminate if we see another space at this point
			set stmp4 WORD_store_word								; continue processing but skip this code
																	;
		@label WORD_store_word										; The actual save operation
			st stmp2 stmp0											; store the character into the character buffer
			addi stmp2 stmp2 1										; move to the next character
			gt stmp1 stmp5 wlen										; did we go over the maximum word length?
			jt stmp1 WORD_too_large_word_ERROR						; If so then error out
			incr stmp5 												; increment the word length count 
			j WORD_read_data										; restart the process
																	;
	@label WORD_too_large_word_ERROR								; we need to setup the pointers for error states
		st stmp2 zero												; rewrite zero to the end of word entry
		set spar1 errmsg_WORD_too_large_word						; load the error message 
		j ERROR														; get out of here!
	@label WORD_done_reading										; WOOOO we're done
		st stmp2 zero												; put a zero in the current cell, or the last one
		jr lr														; return
;-----------------------------------------------------------------------------
; SUBROUTINE
; Load the character defined by the input pointer into the fdcur register, 
; then advance inptr by one
;-----------------------------------------------------------------------------
@label FETCH
	ld fdcur inptr
	incr inptr
	jr lr
	

;-----------------------------------------------------------------------------
; SUBROUTINE
; Store the character in fdcur in the address described by outptr, then 
; advance outptr by one
;-----------------------------------------------------------------------------
@label DEPOSIT
	st outptr fdcur
	incr outptr
	jr lr

;-----------------------------------------------------------------------------
; SUBROUTINE
; Parse a number, has two entry points as described in the book. SIGNED and
; NATURAL. SIGNED starts with a -, natural does not
;-----------------------------------------------------------------------------
@label NUMBER
	swap sp rtop
	push lr
	push inptr
	move inptr spar0
	jl lr FETCH				; setup fdcur
	jl lr SIGNED			; call signed to comb through
	eqi stmp1 fdcur 0x2e	; check to see if fdcur is a .
	jf stmp1 NUMBER_CHECK	; if fdcur isn't a . then we're done
	move spar0 sres0		; move the result to the input
	jl lr NATURAL			; interpret the rest of the digits
@label NUMBER_CHECK
	eq sres1 fdcur space	; if we see a space then this is a number
@label IS_NUMBER
	pop inptr
	pop lr
	swap sp rtop
	jr lr

@label SIGNED				; test to see if the current char is -
	push lr					; 
	move spar0 zero			; Zero out spar0 which is our storage value
	eqi r226 fdcur 0x2d		; Does fdcur == 0x2d ('-')
@label NATURAL
	push stmp1
	push stmp2
	@label NATURAL_CHECK_CHARACTER
		jl lr FETCH					; load the next symbol
		subi stmp1 fdcur 0x30		; subtract 0x30 from the current character, 
		gti stmp2 stmp1 0x9			; if the result is greater than 9 (remember that stmp1 is unsigned)
		jt stmp2 DONE_NATURAL		; then return
		muli spar0 spar0 10			; multiply the current value by 10
		add spar0 spar0 stmp1		; add this digit to new sum
		j NATURAL_CHECK_CHARACTER	; do it again
	@label DONE_NATURAL
		move sres0 spar0			; copy to the return value
		pop stmp2
		pop stmp1
		pop lr
		jr lr
;TODO implement OUTPUT functionality chapter 3.4.3

;-----------------------------------------------------------------------------
; SUBROUTINE
; Pop a word off the top of the parameter stack
;-----------------------------------------------------------------------------
@label WordDrop 
	push stmp0
	swap sp ptop	; load the parameter stack top into sp
	pop stmp0		; pop the top element off the parameter stack
	swap sp ptop	; put the old parameter stack back
	pop stmp0
	jr lr			; DONE BRO

;-----------------------------------------------------------------------------
; SUBROUTINE
; duplicate the top of the parameter stack
;-----------------------------------------------------------------------------
@label WordDup
	push stmp0
	swap sp ptop
	pop stmp0
	push stmp0
	push stmp0
	swap sp ptop
	pop stmp0
	jr lr

;-----------------------------------------------------------------------------
; SUBROUTINE
; swap the top of the parameter stack with the lower word
;-----------------------------------------------------------------------------
@label WordSwap
	push stmp0 			; save registers
	push stmp1			;
	swap sp ptop
	pop stmp0
	pop stmp1
	push stmp0
	push stmp1
	swap sp ptop
	pop stmp1
	pop stmp0
	jr lr

;-----------------------------------------------------------------------------
; SUBROUTINE
; push the lower word on the stack onto the stack (a b -- a b a)
;-----------------------------------------------------------------------------
@label WordOver
	push stmp0			; save registers
	push stmp1			;
	swap sp ptop		; swap sp with the parameter stack
	pop stmp0			; pop the top 
	pop stmp1			; pop the lower
	push stmp1 			; push lower
	push stmp0 			; push top
	push stmp1 			; push lower
	swap sp ptop
	pop stmp1
	pop stmp0
	jr lr




@data
@label msg_newline
	; \n
	@declare 0x0A
	@declare 0x00
@data
@label errmsg_WORD_too_large_word
	; " WORD TOO LARGE!"
	@declare 0x20
	@declare 0x57
	@declare 0x4f
	@declare 0x52
	@declare 0x44
	@declare 0x20
	@declare 0x54
	@declare 0x4f
	@declare 0x4f
	@declare 0x20
	@declare 0x4c
	@declare 0x41
	@declare 0x52
	@declare 0x47
	@declare 0x45
	@declare 0x21
	@declare 0xa
	@declare 0x00
@label WORD_BUFFER
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
	@declare 0x00
