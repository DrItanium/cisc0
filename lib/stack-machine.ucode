;-----------------------------------------------------------------------------
;  stack-machine ucode
;  Copyright (c) 2013-2015, Joshua Scoggins and Contributors
;  All rights reserved.
;  
;  Redistribution and use in source and binary forms, with or without
;  modification, are permitted provided that the following conditions are met:
;      * Redistributions of source code must retain the above copyright
;        notice, this list of conditions and the following disclaimer.
;      * Redistributions in binary form must reproduce the above copyright
;        notice, this list of conditions and the following disclaimer in the
;        documentation and/or other materials provided with the distribution.
;  
;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
;  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
;  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR 
;  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
;  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;-----------------------------------------------------------------------------
; Implementation of a stack machine using iris as a microcoded processor
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; ucode_start: entry-point for the ucode
;-----------------------------------------------------------------------------
 
;-----------------------------------------------------------------------------
; Setup initial register state
;-----------------------------------------------------------------------------
@label ucode_start
	set ?zero 0								; Hardcoded zero
	set ?one 1								; Hardcoded one
	set ?max 0xffff 							; Max
	set ?min 0x0000					   		; Min
	set ?two 2								; Hardcoded two
	set ?three 3								; Hardcoded three
	set ?memstart stack_machine_memory_start		; stack machine memory start
	set ?memend stack_machine_memory_end		; stack machine memory end
	set ?opvec opcode_vector_table				; opcode table base address
	set ?ps0 0								; parameter stack top
	set ?ps1 0								; parameter stack second
	set ?ps2 0								; parameter stack third
	set ?psaddr parameterstackbase				; address of the parameter stack
	set ?pslen 0							    ; stack length
	
	set ?ip program_counter_start			; stack program counter
											; use the internal stack for the return stack
											; registers 32-64 are return registers
											; registers 64-128 are argument registers
											; registers 128-192 are local registers
											; registers 193-224 are global registers
											; register 253 is the link register
											; register 252 is the indirect address register
											; register 251 is a temporary register
@label ucode_loop_top
	set ?iaddr ucode_dispatch_op
	goto.link ?link ucode_internal_call
	goto ucode_loop_top
@label ucode_loop_done
	system 0 ?zero ?zero 					; We should never ever get here
; routines follow
@label ucode_dispatch_op
	addi ?ip ?ip 1
	gt ?pred ?ip ?memend
	goto.if0 ?pred ucode_internal_return
	; right now we should terminate once we have walked through all of memory
	set a0 done_str
	set ?iaddr ucode_printstring
	goto.link ?link ucode_internal_call
	system 0 ?zero ?zero
;-----------------------------------------------------------------------------
; ucode_push_parameter: push a value onto the parameter stack
; a0 - value
;-----------------------------------------------------------------------------
@label ucode_push_parameter
	ge l0 ?pslen ?three 								; check and see if we have three or more elements on the stack already
	goto.if1 l0 ucode_push_parameter_into_memory
	eq l1 ?pslen ?two									; we don't so check and see if it has two elements
	goto.if1 l1 ucode_shift_second_to_third
	set l2 ucode_shift_first_to_second
	set l3 ucode_push_parameter_set_top
	if1 ?pslen l2 l3								; at this point the stack length is either one or zero,
													; so save an instruction and use if then else form
@label ucode_push_parameter_into_memory
	addi ?psaddr ?psaddr 1									; update the address
	store ?psaddr ?ps2							    		; push the third element into memory
@label ucode_shift_second_to_third
	move ?ps2 ?ps1										; move the second to third
@label ucode_shift_first_to_second				
	move ?ps1 ?ps0										; move the first to second
@label ucode_push_parameter_set_top
	move ?ps0 a0
	addi ?pslen ?pslen 1								; increment the stack length
	goto ucode_internal_return

;-----------------------------------------------------------------------------
; ucode_pop_parameter: pop a value off the parameter stack and return it
; ?ret - value to return
;-----------------------------------------------------------------------------
@label ucode_pop_parameter
	goto.if0 ?pslen ucode_no_elements
	move ?ret ?ps0										; we have elements so just save the top of the stack to the return register
	gt l0 ?pslen ?three 								; check and see if we have three or more elements on the stack already
	goto.if1 l0 ucode_pop_more_than_three_elements
	eq l0 ?pslen ?three
	goto.if1 l0 ucode_pop_three_elements
	eq l0 ?pslen ?two									; we don't so check and see if it has two elements
	set l1 ucode_pop_two_elements
	set l2 ucode_pop_one_element
	if1 l0 l1 l2
@label ucode_pop_more_than_three_elements
	move ?ps0 ?ps1
	move ?ps1 ?ps2
	load ?ps2 ?psaddr
	subi ?psaddr ?psaddr 1
	goto ucode_pop_parameter_done
@label ucode_pop_three_elements
	move ?ps0 ?ps1
	move ?ps1 ?ps2
	move ?ps2 ?min
	goto ucode_pop_decrement
@label ucode_pop_two_elements
	move ?ps0 ?ps1
	move ?ps1 ?min
	goto ucode_pop_decrement
@label ucode_pop_one_element
	move ?ps0 ?min
@label ucode_pop_decrement
	subi ?pslen ?pslen 1
	goto ucode_pop_parameter_done
@label ucode_no_elements
	move ?ret ?max
@label ucode_pop_parameter_done
	goto ucode_internal_return

;-----------------------------------------------------------------------------
; ucode_binary_operation: performs the given binary operation using the top two
; elements of the stack, the result is pushed back onto the stack
; a0 - operation (memory address)
; a1
; ?ret - value to return
;-----------------------------------------------------------------------------
@label ucode_binary_operation
	

;-----------------------------------------------------------------------------
; ucode_internal_call: push the link register onto the internal stack and then
; jump to the address in the first argument
; ?link - link register
; ?iaddr - destination
;-----------------------------------------------------------------------------
@label ucode_internal_call
push ?link
jump ?iaddr

;-----------------------------------------------------------------------------
; ucode_internal_return: pop the top address off of the internal stack and 
; jump to it
;-----------------------------------------------------------------------------
@label ucode_internal_return
pop ?temp0
jump ?temp0

@label operation_nop
	jump ?vecret
@label operation_add
	add ?ps0 a0 a1
	jump ?vecret
@label operation_sub
	sub ?ps0 a0 a1
	jump ?vecret
@label operation_mul
	mul ?ps0 a0 a1
	jump ?vecret
@label operation_div
; TODO: insert error checking at some point
	div ?ps0 a0 a1
	jump ?vecret
@label operation_rem
; TODO: insert error checking at some point
	rem ?ps0 a0 a1
	jump ?vecret
@label operation_shift_left
	shl ?ps0 a0 a1
	jump ?vecret
@label operation_shift_right
	shr ?ps0 a0 a1
	jump ?vecret
@label operation_binary_and
	and ?ps0 a0 a1
	jump ?vecret
@label operation_binary_or
	or ?ps0 a0 a1
	jump ?vecret
@label operation_binary_not
	not ?ps0 a0
	jump ?vecret
@label operation_equals
	eq ?ps0 a0 a1
	jump ?vecret
@label operation_not_equals
	ne ?ps0 a0 a1
	jump ?vecret
@label operation_greater_than
	gt ?ps0 a0 a1
	jump ?vecret
@label operation_less_than
	lt ?ps0 a0 a1
	jump ?vecret
@label operation_greater_than_or_equal
	ge ?ps0 a0 a1
	jump ?vecret
@label operation_less_than_or_equal
	le ?ps0 a0 a1
	jump ?vecret
@label operation_dup
	set ?iaddr ucode_push_parameter
	move a0 ?ps0
	goto.link ?link ucode_internal_call
	jump ?vecret
@label operation_swap
	swap ?ps0 ?ps1
	jump ?vecret

@label operation_pushi
	set ?iaddr ucode_push_parameter
	goto.link ?link ucode_internal_call
	jump ?vecret

@label operation_pop
	set ?iaddr ucode_pop_parameter
	goto.link ?link ucode_internal_call
	jump ?vecret

@label operation_clear_stack
	set ?pslen 0
	set ?psaddr parameterstackbase
	jump ?vecret

@label operation_load
	load ?ps0 a0
	jump ?vecret

@label operation_store
	store ?ps0 a0
	jump ?vecret

;-----------------------------------------------------------------------------
; void printstring(char* s1);
;-----------------------------------------------------------------------------
@label ucode_printstring				 	; printstring {
	move l0 a0				; 	argument _s1
	set l1 0					 	; 	predicate := false
	set l2 0					 	; 	terminator := 0
@label printstring_loop			 	; 	loop {
	load l3 l0				 	; 		curr := *s1
	ne l1 l3 l2				; 		predicate = (curr != terminator)
	goto.if0 l1 printstring_done ; 		if !predicate then break
	system 2 l3 l3				; 		print curr // special function
	addi l0 l0 1				; 		s1++
	goto printstring_loop			; 	}
@label printstring_done				;
	goto ucode_internal_return 		; return
								; }

; data sections
@data
; memory is laid out with the lower 
@label stack_machine_memory_start
@label parameterstackbase
@declare 0xFFFF
@label program_counter_start

@label stack_machine_memory_end
@declare 0x0000
@label done_str
@declare 0x64
@declare 0x6f
@declare 0x6e
@declare 0x65
@declare 0x00
@org 0xF000
; opcode vector table
; each entry is several words wide
; first word is the address of the code fragment to execute
; second is the number of input arguments (minus ?vecret, which is always set)
; 
@label opcode_vector_table
@declare operation_nop
@declare 0
@declare operation_add
@declare 2
@declare operation_sub
@declare 2
@declare operation_mul
@declare 2
@declare operation_div
@declare 2
@declare operation_rem
@declare 2
@declare operation_shift_left
@declare 2
@declare operation_shift_right
@declare 2
@declare operation_binary_and
@declare 2
@declare operation_binary_or
@declare 2
@declare operation_binary_not
@declare 1
@declare operation_equals
@declare 2
@declare operation_not_equals
@declare 2
@declare operation_greater_than
@declare 2
@declare operation_less_than
@declare 2
@declare operation_greater_than_or_equal
@declare 2
@declare operation_less_than_or_equal
@declare 2
@declare operation_dup
@declare 0
@declare operation_swap
@declare 0
@declare operation_pushi
@declare 1
@declare operation_pop
@declare 0
@declare operation_clear_stack
@declare 0
@declare operation_load
@declare 1
@declare operation_store
@declare 1
