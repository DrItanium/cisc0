;-----------------------------------------------------------------------------
;  stack-machine ucode
;  Copyright (c) 2013-2015, Joshua Scoggins and Contributors
;  All rights reserved.
;  
;  Redistribution and use in source and binary forms, with or without
;  modification, are permitted provided that the following conditions are met:
;      * Redistributions of source code must retain the above copyright
;        notice, this list of conditions and the following disclaimer.
;      * Redistributions in binary form must reproduce the above copyright
;        notice, this list of conditions and the following disclaimer in the
;        documentation and/or other materials provided with the distribution.
;  
;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
;  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
;  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR 
;  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
;  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;-----------------------------------------------------------------------------
; Implementation of a stack machine using iris as a microcoded processor
;-----------------------------------------------------------------------------
; Setup initial register state
;-----------------------------------------------------------------------------
set ?zero 0								; Hardcoded zero
set ?one 1								; Hardcoded one
set ?max 0xffff 							; Max
set ?min 0x0000					   		; Min
set ?two 2								; Hardcoded two
set ?three 3								; Hardcoded three
set ?memstart stack_machine_memory_start		; stack machine memory start
set ?memend stack_machine_memory_end		; stack machine memory end
set ?opvec opcode_vector_table				; opcode table base address
set ?ps0 0								; parameter stack top
set ?ps1 0								; parameter stack second
set ?ps2 0								; parameter stack third
set ?psaddr parameterstackbase				; address of the parameter stack
set ?pslen 0							    ; stack length

set ?ip program_counter_start			; stack program counter
										; use the internal stack for the return stack
										; registers 32-64 are return registers
										; registers 64-128 are argument registers
										; registers 128-192 are local registers
										; registers 193-224 are global registers
										; register 253 is the link register
										; register 252 is the indirect address register
										; register 251 is a temporary register
;-----------------------------------------------------------------------------
; ucode_start: entry-point for all ucode routines, always the bottom of the
; environment
;-----------------------------------------------------------------------------
@label ucode_start
@label ucode_loop_top

goto ucode_loop_top
@label ucode_loop_done
system 0 ?zero ?zero 					; We should never ever get here
; routines follow
;-----------------------------------------------------------------------------
; ucode_push_parameter: push a value onto the parameter stack
; arg0 - value
;-----------------------------------------------------------------------------
@label ucode_push_parameter
	ge local0 ?pslen ?three 								; check and see if we have three or more elements on the stack already
	goto.if1 local0 ucode_push_parameter_into_memory
	eq local1 ?pslen ?two									; we don't so check and see if it has two elements
	goto.if1 local1 ucode_shift_second_to_third
	set local2 ucode_shift_first_to_second
	set local3 ucode_push_parameter_set_top
	if1 ?pslen local2 local3								; at this point the stack length is either one or zero,
													; so save an instruction and use if then else form
@label ucode_push_parameter_into_memory
	addi ?psaddr ?psaddr 1									; update the address
	store ?psaddr ?ps2							    		; push the third element into memory
@label ucode_shift_second_to_third
	move ?ps2 ?ps1										; move the second to third
@label ucode_shift_first_to_second				
	move ?ps1 ?ps0										; move the first to second
@label ucode_push_parameter_set_top
	move ?ps0 arg0
	addi ?pslen ?pslen 1								; increment the stack length
	goto ucode_internal_return

;-----------------------------------------------------------------------------
; ucode_pop_parameter: pop a value off the parameter stack and return it
; ?ret - value to return
;-----------------------------------------------------------------------------
@label ucode_pop_parameter
	goto.if0 ?pslen ucode_no_elements
	move ?ret ?ps0										; we have elements so just save the top of the stack to the return register
	gt local0 ?pslen ?three 								; check and see if we have three or more elements on the stack already
	goto.if1 local0 ucode_pop_more_than_three_elements
	eq local0 ?pslen ?three
	goto.if1 local0 ucode_pop_three_elements
	eq local0 ?pslen ?two									; we don't so check and see if it has two elements
	set local1 ucode_pop_two_elements
	set local2 ucode_pop_one_element
	if1 local0 local1 local2
@label ucode_pop_more_than_three_elements
	move ?ps0 ?ps1
	move ?ps1 ?ps2
	load ?ps2 ?psaddr
	subi ?psaddr ?psaddr 1
	goto ucode_pop_parameter_done
@label ucode_pop_three_elements
	move ?ps0 ?ps1
	move ?ps1 ?ps2
	move ?ps2 ?min
	goto ucode_pop_decrement
@label ucode_pop_two_elements
	move ?ps0 ?ps1
	move ?ps1 ?min
	goto ucode_pop_decrement
@label ucode_pop_one_element
	move ?ps0 ?min
@label ucode_pop_decrement
	subi ?pslen ?pslen 1
	goto ucode_pop_parameter_done
@label ucode_no_elements
	move ?ret ?max
@label ucode_pop_parameter_done
	goto ucode_internal_return

;-----------------------------------------------------------------------------
; ucode_binary_operation: performs the given binary operation using the top two
; elements of the stack, the result is pushed back onto the stack
; arg0 - operation (memory address)
; arg1
; ?ret - value to return
;-----------------------------------------------------------------------------
@label ucode_binary_operation
	

;-----------------------------------------------------------------------------
; ucode_internal_call: push the link register onto the internal stack and then
; jump to the address in the first argument
; ?link - link register
; ?iaddr - destination
;-----------------------------------------------------------------------------
@label ucode_internal_call
push ?link
jump ?iaddr

;-----------------------------------------------------------------------------
; ucode_internal_return: pop the top address off of the internal stack and 
; jump to it
;-----------------------------------------------------------------------------
@label ucode_internal_return
pop ?temp0
jump ?temp0

@label operation_nop
	jump ?vecret
@label operation_add
	add ?ps0 arg0 arg1
	jump ?vecret
@label operation_sub
	sub ?ps0 arg0 arg1
	jump ?vecret
@label operation_mul
	mul ?ps0 arg0 arg1
	jump ?vecret
@label operation_div
; TODO: insert error checking at some point
	div ?ps0 arg0 arg1
	jump ?vecret
@label operation_rem
; TODO: insert error checking at some point
	rem ?ps0 arg0 arg1
	jump ?vecret
@label operation_shift_left
	shl ?ps0 arg0 arg1
	jump ?vecret
@label operation_shift_right
	shr ?ps0 arg0 arg1
	jump ?vecret
@label operation_binary_and
	and ?ps0 arg0 arg1
	jump ?vecret
@label operation_binary_or
	or ?ps0 arg0 arg1
	jump ?vecret
@label operation_binary_not
	not ?ps0 arg0
	jump ?vecret
@label operation_equals
	eq ?ps0 arg0 arg1
	jump ?vecret
@label operation_not_equals
	ne ?ps0 arg0 arg1
	jump ?vecret
@label operation_greater_than
	gt ?ps0 arg0 arg1
	jump ?vecret
@label operation_less_than
	lt ?ps0 arg0 arg1
	jump ?vecret
@label operation_greater_than_or_equal
	ge ?ps0 arg0 arg1
	jump ?vecret
@label operation_less_than_or_equal
	le ?ps0 arg0 arg1
	jump ?vecret
@label operation_dup
	set ?iaddr ucode_push_parameter
	move arg0 ?ps0
	goto.link ?link ucode_internal_call
	jump ?vecret
@label operation_swap
	swap ?ps0 ?ps1
	jump ?vecret

@label operation_pushi
	set ?iaddr ucode_push_parameter
	goto.link ?link ucode_internal_call
	jump ?vecret

@label operation_pop
	set ?iaddr ucode_pop_parameter
	goto.link ?link ucode_internal_call
	jump ?vecret

@label operation_clear_stack
	set ?pslen 0
	set ?psaddr parameterstackbase
	jump ?vecret

@label operation_load
	load ?ps0 arg0
	jump ?vecret

@label operation_store
	store ?ps0 arg0
	jump ?vecret

; data sections
@data
; memory is laid out with the lower 
@label stack_machine_memory_start
@label parameterstackbase
@declare 0xFFFF
@label program_counter_start

@label stack_machine_memory_end
@declare 0x0000
@org 0xF000
; opcode vector table
; each entry is several words wide
; first word is the address of the code fragment to execute
; second is the number of input arguments (minus ?vecret, which is always set)
; 
@label opcode_vector_table
@declare operation_nop
@declare 0
@declare operation_add
@declare 2
@declare operation_sub
@declare 2
@declare operation_mul
@declare 2
@declare operation_div
@declare 2
@declare operation_rem
@declare 2
@declare operation_shift_left
@declare 2
@declare operation_shift_right
@declare 2
@declare operation_binary_and
@declare 2
@declare operation_binary_or
@declare 2
@declare operation_binary_not
@declare 1
@declare operation_equals
@declare 2
@declare operation_not_equals
@declare 2
@declare operation_greater_than
@declare 2
@declare operation_less_than
@declare 2
@declare operation_greater_than_or_equal
@declare 2
@declare operation_less_than_or_equal
@declare 2
@declare operation_dup
@declare 0
@declare operation_swap
@declare 0
@declare operation_pushi
@declare 1
@declare operation_pop
@declare 0
@declare operation_clear_stack
@declare 0
@declare operation_load
@declare 1
@declare operation_store
@declare 1
