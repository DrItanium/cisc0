The second generation iris core is a 16-bit processor which has 32-bit
instructions.

Some stats:

- 256 general purpose 16-bit registers
- 256 indirect register 8-bit registers 
- Harvard Design
  - 64k instruction words (code domain)
  - 64k data words (data domain)
  - Instruction words are 32-bits in length
  - Data words are 16-bits in length
  - Self-modifying code is not allowed for simplicity reasons (can't access the 
  - 64k data words circular stack (can't overflow into external memory but will
    wraparound by design) which grows down (from address zero downward).
- CISC design (with influence taken from itanium, x86, and RISC designs)
   - Relatively simple decoder logic
- Has three unused execution groups for extension purposes

The general format of the instructions are as follows:

bits 0-2 : mode [3 bits]
bits 3-7 : operation [5 bits]
bits 8-31 : operation bits [24 bits]

These 24 bits are usually broken up into three 8-bit pieces or an 8-bit piece
followed by a 16-bit piece. So the following table will describe different
shorthand the rest of this document will use. Each entry will be of the
following form:

[ Bits | uses | terms ]

[ bits 8-15  | register, index | dest, destination register, first register, reg0, index ]
[ bits 16-23 | register, index | source0, src0, first source register, index ]
[ bits 24-31 | register        | source1, src1, second source register ]
[ bits 16-31 | immediate       | immediate ]

It is important to note that immediate values will ALWAYS be in bits 16-31 in
the instructions which require them. The first register space can sometimes go
unused in the case of some instructions. It is also important to note that one
of improvements to iris is this simplification to how bits are used. 

Iris has support for up to eight instruction groups where only five are
actually in use. The five modes are:

0: Arithmetic
1: Move
2: Jump
3: Compare
4: Misc 
5-7: Undefined (will cause a panic in the simulator at this point in time)

The operation bits are different for each major operation group. 

-------------------------------------------------------------------

For arithmetic operations the format is as follows:
bits 8-15 : destination register
bits 16-23 : first source register
bits 24-31 : second source register


The list of arithmetic operations are as follows (assembler names are
surrounded by [])

0: add [add]
1: subtract [sub]
2: multiply [mul]
3: divide [div]
4: remainder (aka mod) [rem]
5: shift left [shl]
6: shift right [shr]
7: binary and [and]
8: binary or [or]
9: binary not (second source register isn't used, same form though) [not]
10: binary xor  [xor]
11: add immediate [addi]
12: subtract immediate [subi]
13: multiply immediate [muli]
14: divide immediate [divi]
15: remainder immediate [remi]
16: shift left immediate [shli]
17: shift right immediate [shri]
18-31 will cause a panic in the simulator as they are currently undefined

For the immediate forms the only difference is that bits 24-31 are not
interpreted as a register address. Instead it is interpreted as an 8-bit
number. Negative values are not supported so instead of doing:

   addi r0, r1, -1

you should do:

   subi r0, r1, 1

-------------------------------------------------------------------

For move operations the general format is:

register-register form:

   bits 8-15 : register 0
   bits 16-23 : register 1
   bits 24-31 : unused

register-immediate form

   bits 8-15 : register 0
   bits 16-31 : immediate

The list of move operations are as follows:

0: Move Register to Register (register-register)
1: Swap Registers (register-register)
2: Swap Register Contents With Address Contents (register-register)
3: Swap Address Address (register-register)
4: Swap Register Memory (register-immediate)
5: Swap Address Memory (register-immediate)
6: Set (register-immediate)
7: Load (register-register)
8: Load From Memory (register-immediate)
9: Store (register-register)
10: Store Register to Address (register-register)
11: Memory Copy (register-immediate)
12: Memory Set (register-immediate)
13: Push Register Contents onto Stack
14: Push Immediate onto Stack
15: Pop Value Off Stack and Store In Register
16-31: Undefined

>>>>>> Move Register to Register
Opcode: 0
Assembly Command: move reg_dest reg_source
Description: Copies the contents of the source register into the destination
             register..

>>>>>> Swap Registers
Opcode: 1
Assembly Command: swap reg_dest reg_source
Description: Swaps the contents of the source register with the contents of the
             destination register.

>>>>>> Swap Register Contents with Memory Contents
Opcode: 2
Assembly Command: swap.reg.addr reg_dest reg_source
Description: Interprets the source register as a memory address, loads the
             value at that memory location, stores the contents of the
             destination register to that address, and sets the contents of 
             the destination register to the old memory contents.

>>>>>> Swap Memory Using Registers
Opcode: 3
Assembly Command: swap.addr.addr reg_dest reg_source
Description: Interprets the source and destination registers as memory
             addresses, loads the values at each memory location, and then
             stores those values in the other memory address. 

             For example, if we have r0 = 0xA and r1 = 0xB then this operation
             will save the memory pointed at by r0's contents (0xA) into the 
             memory pointed at by r1's contents (0xB) and vice-versa. 

>>>>>> Swap Register Contents Into Immediate Memory Address 
Opcode: 4
Assembly Command: swap.reg.mem reg_dest $immediate 
Description: Interprets the immediate value as a memory address, loads the
             value at that location, saves the contents of the destination
             register into that address, and sets the contents of the
             destination register to the value that was in memory.

>>>>>> Swap Memory Using Register And Immediate Value 
Opcode: 5
Assembly Command: swap.addr.mem reg_dest $immediate 
Description: Swaps the contents of two memory locations pointed at using 
             the contents of the destination register and the supplied
             immediate value.

>>>>>> Set Register With Immediate Value
Opcode: 6
Assembly Command: set reg_dest $immediate
Description: Sets the contents of the destination register to the supplied
             immediate value.

>>>>>> Load 
Opcode: 7
Assembly Command: load reg_dest reg_src
Description: Sets the contents of the destination register to the contents of
             memory pointed at by the contents of the source register.

>>>>>> Load From Memory Using Immediate Value
Opcode: 8
Assembly Command: load.mem reg_dest $immediate
Description: Sets the contents of the destination register to the contents of
             memory pointed at by the immediate.

>>>>>> Store
Opcode: 9
Assembly Command: store dest_reg source_reg
Description: Stores the contents of the source register into memory at the
             address contained in the destination register. 

>>>>>> Memory Copy using Registers
Opcode: 10
Assembly Command: store.addr dest_reg source_reg
Description: Stores the contents of memory found at the address contained in
             the source register into memory at the address described in the
             destination register.
             
>>>>>> Memory Copy using Immediate Value and Register
Opcode: 11
Assembly Command: memcopy dest_reg $immediate
Description: Stores the contents of memory found at the address contained in
             the source register into memory at the address described in the
             destination register.

>>>>>> Memory Set using Immediate Value and Register
Opcode: 12
Assembly Command: memset dest_reg $immediate
Description: Stores the contents of memory found at the address contained in
             the source register into memory at the address described in the
             destination register.

>>>>>> Push Register Contents onto Stack 
Opcode: 13
Assembly Command: push reg 
Description: Increments the contents of the implicit stack pointer register
             (default is r254) and stores the contents of reg at this address
             on the stack. The updated address is written to the stack pointer 
             at the end.

>>>>>> Push Immediate onto Stack 
Opcode: 14
Assembly Command: push.imm $immediate 
Description: Increments the contents of the implicit stack pointer register
             (default is r254) and stores the immediate value at this address
             on the stack. The updated address is written to the stack pointer 
             at the end.

>>>>>> Pop Value Off Stack and Store In Register 
Opcode: 15
Assembly Command: pop reg 
Description: Saves the value at the top of the stack into reg, 
             decrements the stack pointer address, and then saves this updated
             stack pointer address back into the stack pointer.

-------------------------------------------------------------------
For Jump operations, we have three major groups:

- Unconditional
- Conditional True
- Conditional False
- IfThenElse

When dealing with immediate values, the jump operation is called a goto
When dealing with registers, the jump operation is called a jump.

>>>>>> Jump Unconditional Immediate 
Opcode: 0
Assembly Command: goto $immediate
Description: Jumps to the target address
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Unused
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Unconditional Immediate and Link
Opcode: 1
Assembly Command: goto.link dest_reg $immediate
Description: Jumps to the target address and stores the current address in the
             destination register.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index to store current address in (useful for returns)
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Unconditional Register 
Opcode: 2
Assembly Command: jump <addr_register>
Description: Jumps to the target address
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of register containing jump address
   Byte 2-3 : Unused

>>>>>> Jump Unconditional Register and Link
Opcode: 3
Assembly Command: jump.link <linkregister> <addr_register>
Description: Jumps to the target address
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Link Register
   Byte 2 : Index of Address Register
   Byte 3 : Unused

>>>>>> Jump Immediate If True
Opcode: 4
Assembly Command: goto.if1 $immediate
Description: Jumps to the target address provided that the given predicate
             register contains a value which is not zero
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register 
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Immediate If True and Link
Opcode: 5
Assembly Command: goto.if1.link <link_register> $immediate
Description: Jumps to the target address provided that the contents of the
             predicate register (Index defined via implied register) is not
             zero. The current address is stored in the link_register. 
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index to store current address in (useful for returns)
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Register If True 
Opcode: 6
Assembly Command: jump.if1 <predicate_reg> <addr_register>
Description: Jumps to the target address provided the contents of the predicate
             register are not zero.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of the Predicate Register
   Byte 2 : Index of the Address Register
   Byte 3 : Unused

>>>>>> Jump Register If True and Link
Opcode: 7
Assembly Command: jump.if1.link <predicate> <addr> <link>
Description: Jumps to the target address provided the contents of the predicate
             are not zero and saves the current location to the provided link 
             register.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register
   Byte 2 : Index of Address Register
   Byte 3 : Index of Link Register 

>>>>>> Jump Immediate If False
Opcode: 8
Assembly Command: goto.if0 $immediate
Description: Jumps to the target address provided that the given predicate
             register contains a value which is zero
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register 
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Immediate If False and Link
Opcode: 9
Assembly Command: goto.if0.link <link_register> $immediate
Description: Jumps to the target address provided that the contents of the
             predicate register (Index defined via implied register) is zero. 
             The current address is stored in the link_register. 
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index to store current address in (useful for returns)
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Register If False
Opcode: 10 
Assembly Command: jump.if0 <predicate_reg> <addr_register>
Description: Jumps to the target address provided the contents of the predicate
             register are zero.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of the Predicate Register
   Byte 2 : Index of the Address Register
   Byte 3 : Unused

>>>>>> Jump Register If True and Link
Opcode: 11 
Assembly Command: jump.if0.link <predicate> <addr> <link>
Description: Jumps to the target address provided the contents of the predicate
             are zero and saves the current location to the provided link 
             register.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register
   Byte 2 : Index of Address Register
   Byte 3 : Index of Link Register 

>>>>>> If True Then Else 
Opcode: 12
Assembly Command: if1 <predicate> <ontrue> <onfalse> 
Description: If the contents of the predicate register are not zero then jump
             to the address contained in the ontrue register else jump to the
             on false register
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register 
   Byte 2 : Index of On True Register
   Byte 3 : Index of On False Register

>>>>>> If False Then Else 
Opcode: 13
Assembly Command: if0 <predicate> <ontrue> <onfalse> 
Description: If the contents of the predicate register are zero then jump to 
             the address contained in the ontrue register else jump to the
             on false register
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register 
   Byte 2 : Index of On True Register
   Byte 3 : Index of On False Register

>>>>>> If True Then Else and Link
Opcode: 14
Assembly Command: if1.link <link_register> <ontrue> <onfalse> 
Description: If the contents of the predicate register are not zero (implied
             register) then jump to the address contained in the ontrue 
             register else jump to the on false register and save the current
             location to the link register
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Link Register 
   Byte 2 : Index of On True Register
   Byte 3 : Index of On False Register

>>>>>> If False Then Else and Link
Opcode: 15
Assembly Command: if0.link <link_register> <ontrue> <onfalse> 
Description: If the contents of the predicate register (implied register) are 
             zero then jump to the address contained in the ontrue register 
             else jump to the on false register and save the current location 
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Link Register 
   Byte 2 : Index of On True Register
   Byte 3 : Index of On False Register

-------------------------------------------------------------------
For condition operations the form is as follows:

byte 0 : Group + Op (3 + 5 bits)
byte 1 : Destination Register
byte 2 : Source Register 0
byte 3 : Source Register 1

>>>>>> Equals 
Opcode: 0
Assembly Command: eq <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 == src1 and stores the
             result in dest

>>>>>> And Equals 
Opcode: 1
Assembly Command: and.eq <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 == src1 then and's the 
             result with the contents of dest and stores that in dest.
             Basically, dest &= (src0 == src1).

>>>>>> Or Equals 
Opcode: 2
Assembly Command: or.eq <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 == src1 then or's the 
             result with the contents of dest and stores that in dest.
             Basically, dest |= (src0 == src1).

>>>>>> Xor Equals 
Opcode: 3
Assembly Command: xor.eq <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 == src1 then xor's the 
             result with the contents of dest and stores that in dest.
             Basically, dest ^= (src0 == src1).

>>>>>> Not Equals 
Opcode: 4
Assembly Command: ne <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 != src1 and stores the
             result in dest

>>>>>> And Not Equals 
Opcode: 5
Assembly Command: and.ne <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 != src1 then and's the 
             result with the contents of dest and stores that in dest.
             Basically, dest &= (src0 != src1).

>>>>>> Or Not Equals 
Opcode: 6
Assembly Command: or.ne <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 != src1 then or's the 
             result with the contents of dest and stores that in dest.
             Basically, dest |= (src0 != src1).

>>>>>> Xor Not Equals 
Opcode: 7
Assembly Command: xor.ne <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 != src1 then xor's the 
             result with the contents of dest and stores that in dest.
             Basically, dest ^= (src0 != src1).

>>>>>> Less Than 
Opcode: 8
Assembly Command: lt <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 < src1 and stores the
             result in dest

>>>>>> And Less Than 
Opcode: 9
Assembly Command: and.lt <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 < src1 then and's the 
             result with the contents of dest and stores that in dest.
             Basically, dest &= (src0 < src1).

>>>>>> Or Less Than 
Opcode: 10 
Assembly Command: or.lt <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 < src1 then or's the 
             result with the contents of dest and stores that in dest.
             Basically, dest |= (src0 < src1).

>>>>>> Xor Less Than 
Opcode: 11
Assembly Command: xor.lt <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 < src1 then xor's the 
             result with the contents of dest and stores that in dest.
             Basically, dest ^= (src0 < src1).

>>>>>> Greater Than 
Opcode: 12
Assembly Command: gt <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 > src1 and stores the
             result in dest

>>>>>> And Greater Than 
Opcode: 13 
Assembly Command: and.gt <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 > src1 then and's the 
             result with the contents of dest and stores that in dest.
             Basically, dest &= (src0 > src1).

>>>>>> Or Greater Than 
Opcode: 14 
Assembly Command: or.gt <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 > src1 then or's the 
             result with the contents of dest and stores that in dest.
             Basically, dest |= (src0 > src1).

>>>>>> Xor Greater Than 
Opcode: 15
Assembly Command: xor.gt <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 > src1 then xor's the 
             result with the contents of dest and stores that in dest.
             Basically, dest ^= (src0 > src1).

>>>>>> Less Than Or Equal To 
Opcode: 16
Assembly Command: le <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 <= src1 and stores the
             result in dest

>>>>>> And Less Than Or Equal To 
Opcode: 17 
Assembly Command: and.le <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 <= src1 then and's the 
             result with the contents of dest and stores that in dest.
             Basically, dest &= (src0 <= src1).

>>>>>> Or Less Than Or Equal To 
Opcode: 18 
Assembly Command: or.le <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 <= src1 then or's the 
             result with the contents of dest and stores that in dest.
             Basically, dest |= (src0 <= src1).

>>>>>> Xor Less Than Or Equal To 
Opcode: 19
Assembly Command: xor.le <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 <= src1 then xor's the 
             result with the contents of dest and stores that in dest.
             Basically, dest ^= (src0 <= src1).

>>>>>> Greater Than Or Equal To 
Opcode: 20 
Assembly Command: ge <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 >= src1 and stores the
             result in dest

>>>>>> And Greater Than Or Equal To 
Opcode: 21
Assembly Command: and.ge <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 >= src1 then and's the 
             result with the contents of dest and stores that in dest.
             Basically, dest &= (src0 >= src1).

>>>>>> Or Greater Than Or Equal To 
Opcode: 22
Assembly Command: or.ge <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 >= src1 then or's the 
             result with the contents of dest and stores that in dest.
             Basically, dest |= (src0 >= src1).

>>>>>> Xor Greater Than Or Equal To 
Opcode: 23
Assembly Command: xor.ge <dest> <src0> <src1> 
Description: Checks to see if the contents of src0 >= src1 then xor's the 
             result with the contents of dest and stores that in dest.
             Basically, dest ^= (src0 >= src1).

---------------------------------------------------------------------
The misc op group has the following operations:

>>>>>> System Call
Opcode: 0
Assembly Command: system $<operation> <reg> <reg> 
Description: Performs a system call which taps into system calls described by
             the simulator (at this point there is no trap handler nor trap 
             instructions). Takes in an index and two registers used as
             arguments.
Layout:
   byte 1: System operation index (0-255), immediate value
   byte 2: Index of first input register
   byte 3: Index of second input register

System Operations (this list may not always be up to date, see source to make
                   sure)
   1) Halt - Terminates the simulator or system
   2) getc - Gets a character from standard input and stores the result in reg0 
   3) putc - prints the character stored in reg0 to standard out 
   4) panic - crashes the simulator and provides a core dump
   5-255) Undefined


>>>>>> Set Implicit Register Immediate
Opcode: 1
Assembly Command: implicit.register.set $<index> <reg> 
Description: Sets the target register to use implicitly for operations which
             require more operands than allowed in the actual encoding space.
             The lower 8-bits of the register's contents are stored in the 
             byte register at the provided immediate index. Keep in mind that
             one could use implicit register offsets as extra storage but be
             aware that unused implicit registers may become used in later
             implementations of the iris core.

Layout:
   byte 1: Implicit register index 
   byte 2: Index of register
   byte 3: Unused

>>>>>> Set Implicit Register Indirect 
Opcode: 2
Assembly Command: implicit.register.indirect.set <index_reg> <value_reg> 
Description: Sets the target register to use implicitly for operations which
             require more operands than allowed in the actual encoding space.
             The lower 8-bits of the register's contents are stored in the 
             implicit byte register at the index located in the lower 8-bits of
             the index register. Keep in mind that one could use implicit 
             register offsets as extra storage but be aware that unused 
             implicit registers may become used in later implementations of the 
             iris core.

Layout:
   byte 1: index register (lower 8-bits)
   byte 2: value register (lower 8-bits)
   byte 3: Unused

>>>>>> Get Implicit Register Immediate
Opcode: 3
Assembly Command: implicit.register.get <reg> $<index> 
Description: Retrieves the value stored in the given implicit register 
             described by the immediate index and stores it in the provided
             register. Keep in mind, that this information is useful if you
             want to temporary swap implicit register targets.

Layout:
   byte 1: Register to store contents of indirect register in
   byte 2: Immediate indirect register index
   byte 3: Unused

>>>>>> Get Implicit Register Indirect 
Opcode: 4
Assembly Command: implicit.register.indirect.get <value_reg> <index_reg>
Description: Retrieves the value stored in the given implicit register 
             described by the lower 8-bits of the provided value register 
             and stores it in the value register. Keep in mind, that this 
             information is useful if you want to temporary swap implicit
             register targets.

Layout:
   byte 1: value register (lower 8-bits)
   byte 2: index register (lower 8-bits)
   byte 3: Unused


