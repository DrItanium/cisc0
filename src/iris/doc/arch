The second generation iris core is a 16-bit processor which has 32-bit
instructions.

Some stats:

- 256 general purpose 16-bit registers
- 256 indirect register 8-bit registers 
- Harvard Design
  - 64k instruction words (code domain)
  - 64k data words (data domain)
  - Instruction words are 32-bits in length
  - Data words are 16-bits in length
  - Self-modifying code is not allowed for simplicity reasons (can't access the 
- CISC design (with influence taken from itanium, x86, and RISC designs)
   - Relatively simple decoder logic
- Has three unused execution groups for extension purposes

The general format of the instructions are as follows:

bits 0-2 : mode [3 bits]
bits 3-7 : operation [5 bits]
bits 8-31 : operation bits [24 bits]

These 24 bits are usually broken up into three 8-bit pieces or an 8-bit piece
followed by a 16-bit piece. So the following table will describe different
shorthand the rest of this document will use. Each entry will be of the
following form:

[ Bits | uses | terms ]

[ bits 8-15  | register, index | dest, destination register, first register, reg0, index ]
[ bits 16-23 | register, index | source0, src0, first source register, index ]
[ bits 24-31 | register        | source1, src1, second source register ]
[ bits 16-31 | immediate       | immediate ]

It is important to note that immediate values will ALWAYS be in bits 16-31 in
the instructions which require them. The first register space can sometimes go
unused in the case of some instructions. It is also important to note that one
of improvements to iris is this simplification to how bits are used. 

Iris has support for up to eight instruction groups where only five are
actually in use. The five modes are:

0: Arithmetic
1: Move
2: Jump
3: Compare
4: Misc 
5-7: Undefined (will cause a panic in the simulator at this point in time)

The operation bits are different for each major operation group. 

-------------------------------------------------------------------

For arithmetic operations the format is as follows:
bits 8-15 : destination register
bits 16-23 : first source register
bits 24-31 : second source register


The list of arithmetic operations are as follows:

0: add
1: subtract
2: multiply 
3: divide
4: remainder (aka mod)
5: shift left
6: shift right
7: binary and
8: binary or
9: binary not (second source register isn't used, same form though)
10: binary xor
11-31 will cause a panic in the simulator as they are currently undefined

-------------------------------------------------------------------

For move operations the general format is:

register-register form:

   bits 8-15 : register 0
   bits 16-23 : register 1
   bits 24-31 : unused

register-immediate form

   bits 8-15 : register 0
   bits 16-31 : immediate

The list of move operations are as follows:

0: Move Register to Register (register-register)
1: Swap Registers (register-register)
2: Swap Register Contents With Address Contents (register-register)
3: Swap Address Address (register-register)
4: Swap Register Memory (register-immediate)
5: Swap Address Memory (register-immediate)
6: Set (register-immediate)
7: Load (register-register)
8: Load From Memory (register-immediate)
9: Store (register-register)
10: Store Register to Address (register-register)
11: Memory Copy (register-immediate)
12: Memory Set (register-immediate)
13-31: Undefined

>>>>>> Move Register to Register
Opcode: 0
Assembly Command: move reg_dest reg_source
Description: Copies the contents of the source register into the destination
             register..

>>>>>> Swap Registers
Opcode: 1
Assembly Command: swap reg_dest reg_source
Description: Swaps the contents of the source register with the contents of the
             destination register.

>>>>>> Swap Register Contents with Memory Contents
Opcode: 2
Assembly Command: swap.reg.addr reg_dest reg_source
Description: Interprets the source register as a memory address, loads the
             value at that memory location, stores the contents of the
             destination register to that address, and sets the contents of 
             the destination register to the old memory contents.

>>>>>> Swap Memory Using Registers
Opcode: 3
Assembly Command: swap.addr.addr reg_dest reg_source
Description: Interprets the source and destination registers as memory
             addresses, loads the values at each memory location, and then
             stores those values in the other memory address. 

             For example, if we have r0 = 0xA and r1 = 0xB then this operation
             will save the memory pointed at by r0's contents (0xA) into the 
             memory pointed at by r1's contents (0xB) and vice-versa. 

>>>>>> Swap Register Contents Into Immediate Memory Address 
Opcode: 4
Assembly Command: swap.reg.mem reg_dest $immediate 
Description: Interprets the immediate value as a memory address, loads the
             value at that location, saves the contents of the destination
             register into that address, and sets the contents of the
             destination register to the value that was in memory.

>>>>>> Swap Memory Using Register And Immediate Value 
Opcode: 5
Assembly Command: swap.addr.mem reg_dest $immediate 
Description: Swaps the contents of two memory locations pointed at using 
             the contents of the destination register and the supplied
             immediate value.

>>>>>> Set Register With Immediate Value
Opcode: 6
Assembly Command: set reg_dest $immediate
Description: Sets the contents of the destination register to the supplied
             immediate value.

>>>>>> Load 
Opcode: 7
Assembly Command: load reg_dest reg_src
Description: Sets the contents of the destination register to the contents of
             memory pointed at by the contents of the source register.

>>>>>> Load From Memory Using Immediate Value
Opcode: 8
Assembly Command: load.mem reg_dest $immediate
Description: Sets the contents of the destination register to the contents of
             memory pointed at by the immediate.

>>>>>> Store
Opcode: 9
Assembly Command: store dest_reg source_reg
Description: Stores the contents of the source register into memory at the
             address contained in the destination register. 

>>>>>> Memory Copy using Registers
Opcode: 10
Assembly Command: store.addr dest_reg source_reg
Description: Stores the contents of memory found at the address contained in
             the source register into memory at the address described in the
             destination register.
             
>>>>>> Memory Copy using Immediate Value and Register
Opcode: 11
Assembly Command: memcopy dest_reg $immediate
Description: Stores the contents of memory found at the address contained in
             the source register into memory at the address described in the
             destination register.

>>>>>> Memory Set using Immediate Value and Register
Opcode: 12
Assembly Command: memset dest_reg $immediate
Description: Stores the contents of memory found at the address contained in
             the source register into memory at the address described in the
             destination register.

-------------------------------------------------------------------
For Jump operations, we have three major groups:

- Unconditional
- Conditional True
- Conditional False
- IfThenElse

When dealing with immediate values, the jump operation is called a goto
When dealing with registers, the jump operation is called a jump.

>>>>>> Jump Unconditional Immediate 
Opcode: 0
Assembly Command: goto $immediate
Description: Jumps to the target address
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Unused
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Unconditional Immediate and Link
Opcode: 1
Assembly Command: goto.link dest_reg $immediate
Description: Jumps to the target address and stores the current address in the
             destination register.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index to store current address in (useful for returns)
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Unconditional Register 
Opcode: 2
Assembly Command: jump <addr_register>
Description: Jumps to the target address
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of register containing jump address
   Byte 2-3 : Unused

>>>>>> Jump Unconditional Register and Link
Opcode: 3
Assembly Command: jump.link <linkregister> <addr_register>
Description: Jumps to the target address
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Link Register
   Byte 2 : Index of Address Register
   Byte 3 : Unused

>>>>>> Jump Immediate If True
Opcode: 4
Assembly Command: goto.if1 $immediate
Description: Jumps to the target address provided that the given predicate
             register contains a value which is not zero
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register 
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Immediate If True and Link
Opcode: 5
Assembly Command: goto.if1.link <link_register> $immediate
Description: Jumps to the target address provided that the contents of the
             predicate register (Index defined via implied register) is not
             zero. The current address is stored in the link_register. 
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index to store current address in (useful for returns)
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Register If True 
Opcode: 6
Assembly Command: jump.if1 <predicate_reg> <addr_register>
Description: Jumps to the target address provided the contents of the predicate
             register are not zero.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of the Predicate Register
   Byte 2 : Index of the Address Register
   Byte 3 : Unused

>>>>>> Jump Register If True and Link
Opcode: 7
Assembly Command: jump.if1.link <predicate> <addr> <link>
Description: Jumps to the target address provided the contents of the predicate
             are not zero and saves the current location to the provided link 
             register.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register
   Byte 2 : Index of Address Register
   Byte 3 : Index of Link Register 

>>>>>> Jump Immediate If False
Opcode: 8
Assembly Command: goto.if0 $immediate
Description: Jumps to the target address provided that the given predicate
             register contains a value which is zero
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register 
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Immediate If False and Link
Opcode: 9
Assembly Command: goto.if0.link <link_register> $immediate
Description: Jumps to the target address provided that the contents of the
             predicate register (Index defined via implied register) is zero. 
             The current address is stored in the link_register. 
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index to store current address in (useful for returns)
   Byte 2-3 : immediate value, little endian

>>>>>> Jump Register If False
Opcode: 10 
Assembly Command: jump.if0 <predicate_reg> <addr_register>
Description: Jumps to the target address provided the contents of the predicate
             register are zero.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of the Predicate Register
   Byte 2 : Index of the Address Register
   Byte 3 : Unused

>>>>>> Jump Register If True and Link
Opcode: 11 
Assembly Command: jump.if0.link <predicate> <addr> <link>
Description: Jumps to the target address provided the contents of the predicate
             are zero and saves the current location to the provided link 
             register.
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register
   Byte 2 : Index of Address Register
   Byte 3 : Index of Link Register 

>>>>>> If True Then Else 
Opcode: 12
Assembly Command: if1 <predicate> <ontrue> <onfalse> 
Description: If the contents of the predicate register are not zero then jump
             to the address contained in the ontrue register else jump to the
             on false register
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register 
   Byte 2 : Index of On True Register
   Byte 3 : Index of On False Register

>>>>>> If False Then Else 
Opcode: 13
Assembly Command: if0 <predicate> <ontrue> <onfalse> 
Description: If the contents of the predicate register are zero then jump to 
             the address contained in the ontrue register else jump to the
             on false register
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Predicate Register 
   Byte 2 : Index of On True Register
   Byte 3 : Index of On False Register

>>>>>> If True Then Else and Link
Opcode: 14
Assembly Command: if1.link <link_register> <ontrue> <onfalse> 
Description: If the contents of the predicate register are not zero (implied
             register) then jump to the address contained in the ontrue 
             register else jump to the on false register and save the current
             location to the link register
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Link Register 
   Byte 2 : Index of On True Register
   Byte 3 : Index of On False Register

>>>>>> If False Then Else and Link
Opcode: 15
Assembly Command: if0.link <link_register> <ontrue> <onfalse> 
Description: If the contents of the predicate register (implied register) are 
             zero then jump to the address contained in the ontrue register 
             else jump to the on false register and save the current location 
Layout:
   Byte 0 : Group + Opcode
   Byte 1 : Index of Link Register 
   Byte 2 : Index of On True Register
   Byte 3 : Index of On False Register

-------------------------------------------------------------------
For condition operations the form is as follows:

bit  15 : unused
bits 12-14 : Combine bits
bits 9-11 : Second register
bits 6-8 : First register
bits 3-5 : Conditional operation type

The types of conditional operations are as follows:

0 : Equals
1 : Not equals
2 : Less than
3 : Greater than
4 : Less than or equal to
5 : Greater than or equal to
6,7 : Not defined (will cause a panic in the simulator)

The combine bits are used to support multiple conditions by applying the result
of the compare to the current predicate value. The following values are values
for the combine bits

0 : set (overwrite)
1 : and (and the new value with the old)
2 : or (or the new value with the old)
3 : xor (xor the new value with the old)
4-7 : Unused bits (will cause the simulator to panic)

---------------------------------------------------------------------
The system call operation is as follows:

bits 13-15 : Second register
bits 10-12 : First register
bits 3-9 : Operation

The system call operation suports up to 128 different system calls and its
implementation is system dependent so it is up to the designer how to implement
this and its behavior.
