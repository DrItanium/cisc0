The iris core is a simple 8-bit processor which has 16-bit instructions.

Some stats:

- 8 general purpose 8-bit registers
- CISC design (with influence taken from itanium, x86, and RISC designs)
- Instructions are fixed at 16-bits in length
- 64k of memory
- Simple decoder logic
- Easy to extend due to 4 unused execution groups



The general format of the instructions are as follows:

bits 13-15 : operation group [3 bits]
bits 0-12 : operation bits [13 bits]

Iris has support for up to eight instruction groups where only four are
actually in use. The four modes are:

0: Arithmetic
1: Move
2: Jump
3: Compare
4-7: Undefined (will cause a panic in the simulator at this point in time)

The operation bits are different for each major operation group. 

-------------------------------------------------------------------

For arithmetic operations the format is as follows:

bits 9-12 : specific operation
bits 6-8 : destination register
bits 3-5 : first source register
bits 0-2 : second source register

The list of arithmetic operations are as follows:

0 add
1 subtract
2 multiply 
3 divide
4 remainder (aka mod)
5 shift left
6 shift right
7 binary and
8 binary or
9 binary not (second source register isn't used, same form though)
10 binary xor
11-15 will cause a panic in the simulator as they are currently undefined

-------------------------------------------------------------------

For move operations the general format is:

bits 11-12 : specific operation
bits 8-10 : first register (source or destination dependent on mode)
bits 0-7 : mode specific bits

There are a potential four different modes for a move operation in the iris
core.

0: Register to Register 
1: Immediate to Register 
2: Register to Address (has load and store functionality)
3: Undefined (will cause a panic in the simulator if used)

>>>>>> Register to Register mode
In the register to register mode the remaining bits are as follows:

bits 5-7 : second register
bits 0-4  : unused

In this mode the first register is the destination and the second register
source.

>>>>>> Immediate to Register mode
In this mode the remaining bits are as follows:

bits 0-7 : immediate value

this immediate value is written to the first register

>>>>>> Register to Address mode [Load/Store]
In this mode the remaining bits are as follows:

bits 5-7 : second register [lower half]
bits 2-4 : third register [upper half]
bit 1 : access mode [load or store]
bit 0 : unused

In this mode the second and third register are used to create a 16-bit absolute
address. This address is used different depending on access mode where:

0 : Load 
1 : Store

In load mode, the contents of the computed address are saved into the first
register. In store mode, the contents of the first register are saved into
memory at the computed address. The 16-bit address is built as follows:

0-7 : contents of second register
8-15 : contents of third register

The move instruction is a very important instruction which provides load and
store functionality depending on mode bits set. It is impossible for both to
occur at the same time.

-------------------------------------------------------------------
For jump operations the general format is:

bit 12 : The jump distance 
bits 10-11 : The conditional type
bit 9 : Immediate mode?
bit 8 : Signed mode?

There are two distances that one can jump:

0: Relative (8-bit "Short Jump")
1: Absolute (16-bit "Long Jump")

A relative jump is one where we append an 8-bit value to the program counter.
Whereas an absolute jump is setting the address to a given value. The
differences will be described after defining the rest of the bits below

There are four different conditional Jump types:

0: Unconditional
1: If True
2: If False
3: If then else 

An unconditional jump means exactly what it sounds like.....an unconditional
jump. The other two valid modes are to jump if the predicate bit is set to one
(true) or to jump if the predicate bit is set to zero (false). The final mode
is a register mode specific version which allows if/else behavior. It is
important to note that this final mode is interpreted differently from the
other jump instructions.

The immediate mode bit defines two types of execution:

0 : Register mode
1 : Immediate mode

It is important to note that performing a long jump disallows the use of
immediate mode, the value of this bit is not read!

The signed mode bit defines how an immediate relative address is interpreted:

0 : Treat as unsigned 
1 : Treat as signed

This allows a backwards jump for up to 128 bytes or 64 instructions and a
forward jump of upto 127 bytes or 63 instructions + 1 slop byte.

Since there are so many combinations it is important to describe the different
data representation modes.

>>>>>> Absolute Jump (Unconditional or If True or If False)
An absolute jump only has one mode that is to use two registers in the same
fashion as done for loads and stores.

bits 5-7 : contents of the first register (lower-half)
bits 2-4 : contents of the second register (upper-half)
bits 0-1 : unused

>>>>>> Immediate Relative Jump 
       (Signed or Unsigned, Unconditional or If True or If False)

An immediate relative jump uses consumes the remaning 8 bits as follows:

bits 0-7 : Immediate value

In this style the immediate value is combined with the program counter to
define where to next read instructions from. 


>>>>>> Register Relative Jump 
       (Signed or Unsigned, Unconditional or If True or If False)

A register value relative jump consumes the remaining 8 bits as follows:

bits 5-7 : the target register
bits 0-4 : unused

>>>>>> If Then else Jump

This is a special mode which allows for instruction compression in cases where
fallthrough to the next instruction is not desirable. The decoder interprets
these bits a tad differently from the other.

bit 9 : Conditional style
bit 8 : Condition met register is signed
bit 5-7 : Register to use if condition is met
bit 4 : Condition is not met register is signed
bit 1-3 : Register to use if condition is not met
bit 0 : unused 

The immediate mode bit is now repurposed to describe how the condition should
go:

0 : predicate != 0  (If True Equivalent)
1 : predicate == 0  (If False Equivalent)

This form is always relative due to the amount of space required to describe an
absolute jump and encode four registers while remaining flexible in what
registers can be used.

-------------------------------------------------------------------
For condition operations the form is as follows:

bits 10-12 : Conditional operation type
bits 7-9 : First register
bits 4-6 : Second register
bits 1-3 : Combine bits
bit  0 : unused

The types of conditional operations are as follows:

0 : Equals
1 : Not equals
2 : Less than
3 : Greater than
4 : Less than or equal to
5 : Greater than or equal to
6,7 : Not defined (will cause a panic in the simulator)

The combine bits are used to support multiple conditions by applying the result
of the compare to the current predicate value. The following values are values
for the combine bits

0 : set (overwrite)
1 : and (and the new value with the old)
2 : or (or the new value with the old)
3 : xor (xor the new value with the old)
4-7 : Unused bits (will cause the simulator to panic)
